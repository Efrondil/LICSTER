

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="de" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="de" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4. Secure Communication &mdash; LICSTER 2020 Dokumentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Stichwortverzeichnis" href="genindex.html" />
    <link rel="search" title="Suche" href="search.html" />
    <link rel="next" title="5. Webapplikation Backend" href="webapp.html" />
    <link rel="prev" title="3. Intrusion Detection System" href="ids.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> LICSTER
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="einleitung.html">1. Einleitung</a></li>
<li class="toctree-l1"><a class="reference internal" href="kommunikation.html">2. Workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="ids.html">3. Intrusion Detection System</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. Secure Communication</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#einleitung">4.1. Einleitung</a></li>
<li class="toctree-l2"><a class="reference internal" href="#secure-layer">4.2. Secure Layer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">4.2.1. Bridge</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">4.2.2. Bridgemanager</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#remote-io">4.3. Remote-IO</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mbed-tls">4.3.1. Mbed TLS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#heap-speicher">4.3.2. Heap Speicher</a></li>
<li class="toctree-l3"><a class="reference internal" href="#network-stack">4.3.3. Network Stack</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modbus">4.3.4. Modbus</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#zertifikate">4.4. Zertifikate</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fazit-und-ausblick">4.5. Fazit und Ausblick</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#fazit">4.5.1. Fazit</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ausblick">4.5.2. Ausblick</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="webapp.html">5. Webapplikation Backend</a></li>
<li class="toctree-l1"><a class="reference internal" href="probleme.html">6. Probleme</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">LICSTER</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li><span class="section-number">4. </span>Secure Communication</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/seccom.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="secure-communication">
<h1><span class="section-number">4. </span>Secure Communication<a class="headerlink" href="#secure-communication" title="Link zu dieser Überschrift">¶</a></h1>
<div class="section" id="einleitung">
<h2><span class="section-number">4.1. </span>Einleitung<a class="headerlink" href="#einleitung" title="Link zu dieser Überschrift">¶</a></h2>
<p>Als die Secure Communication Gruppe haben wir uns ausschließlich mit der internen Kommunikation des LICSTERs auseinandergesetzt. Als Ziel haben wir es uns gesetzt das bereits implementierte Modbus-Protokoll, das in dieser Form sich als sehr unsicher bewiesen hat, zu verschlüsseln. Dabei haben wir uns dazu entschieden, das TLS-Protokoll einzusetzen. Dieses bietet zusätzlich zu der Verschlüsselung der Anwendungsschicht ein Handshake-Protokoll, das die Authentifizierung der Kommunikationspartner ermöglicht.</p>
<p>Veranschaulichung der ursprünglichen Kommunikation:<span class="raw-html-m2r"><br></span></p>
<a class="reference external image-reference" href="./assets/diagrams/No_Secure_Layer_Overview.svg"><img alt="" src="_images/No_Secure_Layer_Overview.svg" /></a>
<p>Dies wurde realisiert, indem wir eine zusätzliche Softwareschnittstelle (Secure Layer) im PLC implementiert haben. Diese ermöglicht eine beidseitig verschlüsselte Kommunikation zwischen dem PLC und den Remote-IOs, indem sie eingehende Pakete von den Remote-IOs entschlüsselt und von dem PLC ausgehende Pakete verschlüsselt. Die interne Kommunikation im PLC zwischen dem Secure-Layer und dem OpenPLC findet unverschlüsselt statt.</p>
<p>Veranschaulichung mit Secure Layer:<span class="raw-html-m2r"><br></span></p>
<a class="reference external image-reference" href="./assets/diagrams/Secure_Layer_Overview.svg"><img alt="" src="_images/Secure_Layer_Overview.svg" /></a>
</div>
<div class="section" id="secure-layer">
<h2><span class="section-number">4.2. </span>Secure Layer<a class="headerlink" href="#secure-layer" title="Link zu dieser Überschrift">¶</a></h2>
<p>Der Secure Layer (sichere Schicht) ist die Komponente die zwischen den Remote-IOs und OpenPLC sitz.</p>
<p>Detaillierte Veranschaulichung:<span class="raw-html-m2r"><br></span></p>
<a class="reference external image-reference" href="./assets/diagrams/Secure_Layer_Details.svg"><img alt="" src="_images/Secure_Layer_Details.svg" /></a>
<p>Der Secure Layer ist in Python3.6 geschrieben und in 2 Hauptkomponenten zu unterteilen:</p>
<ul class="simple">
<li><p><a class="reference external" href="#bridge">Bridge</a></p></li>
<li><p><a class="reference external" href="#bridgemanager">Bridgemanager</a></p></li>
</ul>
<div class="section" id="id1">
<h3><span class="section-number">4.2.1. </span>Bridge<a class="headerlink" href="#id1" title="Link zu dieser Überschrift">¶</a></h3>
<p>Die Bridge (Brücke) besteht aus zwei TCP Verbindungen, eine TLS Verbindung zu einem Remote TCP Server, und einen lokalen TCP Server der auf eine lokale Verbindung wartet.<span class="raw-html-m2r"><br></span>
Um dies zu ermöglichen muss die Bridge ein wenig Modbus verstehen, da das Message-Framing in diesem Fall durch Informationen im Header vom Modbus Protokoll vorhanden ist.</p>
</div>
<div class="section" id="id2">
<h3><span class="section-number">4.2.2. </span>Bridgemanager<a class="headerlink" href="#id2" title="Link zu dieser Überschrift">¶</a></h3>
<p>Der Bridgemanager (Brückenverwalter) verwaltet die einzelnen Brücken und startet diese bei Fehlern neu.
<span class="raw-html-m2r"><!-- TODO: evtl. ausführlicher --></span></p>
</div>
</div>
<div class="section" id="remote-io">
<h2><span class="section-number">4.3. </span>Remote-IO<a class="headerlink" href="#remote-io" title="Link zu dieser Überschrift">¶</a></h2>
<!-- TODO: evtl. kleine Einleitung bzw. Erläuterung --><div class="section" id="mbed-tls">
<h3><span class="section-number">4.3.1. </span>Mbed TLS<a class="headerlink" href="#mbed-tls" title="Link zu dieser Überschrift">¶</a></h3>
<p>Um TLS auf den Remote-IOs zu implementieren haben wurde die Mbed TLS Bibliothek gewählt, da diese kompakt, portabel und einfach verständlich ist. Hierbei handelt es sich um ein Open-Source Projekt, welches auf GitHub (<a class="reference external" href="https://github.com/ARMmbed/mbedtls">https://github.com/ARMmbed/mbedtls</a>) zu finden ist. Ein weiterer Grund der für Mbed TLS gesprochen hat ist die Tatsache, dass es innerhalb STM32CubeMX konfiguriert werden kann, und dadurch viel Zeit beim konfigurieren der Bibliothek gespart werden kann.</p>
</div>
<div class="section" id="heap-speicher">
<h3><span class="section-number">4.3.2. </span>Heap Speicher<a class="headerlink" href="#heap-speicher" title="Link zu dieser Überschrift">¶</a></h3>
<p>FreeRTOS verwaltet den gesamten Heap Speicher, darum schlagen Aufrufe der Standardbibliotheksfunktionen für dynamische Speicherverwaltung fehl. Das heißt jeder Aufruf an <code class="docutils literal notranslate"><span class="pre">calloc</span></code> oder <code class="docutils literal notranslate"><span class="pre">malloc</span></code> geben <code class="docutils literal notranslate"><span class="pre">NULL</span></code> zurück. Jedoch benötigt Mbed TLS dynamischen Speicher. Explizit benötigt Mbed TLS <code class="docutils literal notranslate"><span class="pre">calloc</span></code> und <code class="docutils literal notranslate"><span class="pre">free</span></code>. Alternativ kann Mbed TLS auch mit einem statischen Block an Speicher arbeiten, jedoch wurde den dynamischen Ansatz gewählt.
<span class="raw-html-m2r"><!-- TODO: WARUM DYNAMISCHER ANSATZ UND NICHT STATISCHER! --></span></p>
<p>Diese Implementation ist in <code class="docutils literal notranslate"><span class="pre">heap_mem.h</span></code> deklariert und in <code class="docutils literal notranslate"><span class="pre">heap_mem.c</span></code> definiert.</p>
<p><code class="docutils literal notranslate"><span class="pre">heap_mem.c</span></code> beinhaltet Folgenden Quellcode:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;heap_mem.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;cmsis_os.h&quot;</span><span class="cp"></span>

<span class="k">extern</span> <span class="n">SemaphoreHandle_t</span> <span class="n">alloc_mutex</span><span class="p">;</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">rmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">xSemaphoreTake</span><span class="p">(</span><span class="n">alloc_mutex</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pdTRUE</span><span class="p">);</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">pvPortMalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
        <span class="n">xSemaphoreGive</span><span class="p">(</span><span class="n">alloc_mutex</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">rcalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">num</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">total</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">xSemaphoreTake</span><span class="p">(</span><span class="n">alloc_mutex</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pdTRUE</span><span class="p">);</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">pvPortMalloc</span><span class="p">(</span><span class="n">total</span><span class="p">);</span>
        <span class="n">xSemaphoreGive</span><span class="p">(</span><span class="n">alloc_mutex</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">total</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rfree</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">xSemaphoreTake</span><span class="p">(</span><span class="n">alloc_mutex</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pdTRUE</span><span class="p">);</span>
        <span class="n">vPortFree</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
        <span class="n">xSemaphoreGive</span><span class="p">(</span><span class="n">alloc_mutex</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Um diese problemlose Nebenläufigkeit in unserer eigenen Implementierung zu gewährleisten werden alle kritischen Vorgänge mit einem Mutex, bzw. Semaphore abgesichert. Der Code der das gewährleistet ist Folgender:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Warte bis die Lock von dem Mutext genommen werden kann,</span>
<span class="cm"> * d.h. bis es sicher ist das kein (anderer) Thread</span>
<span class="cm"> * die Lock vom Mutex besitzt.</span>
<span class="cm"> */</span>
<span class="k">while</span> <span class="p">(</span><span class="n">xSemaphoreTake</span><span class="p">(</span><span class="n">net_mutex</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pdTRUE</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Gebe die Lock von dem Mutext ab,</span>
<span class="cm"> * sodass sie von einem (anderen) genommen werden kann.</span>
<span class="cm"> */</span>
<span class="n">xSemaphoreGive</span><span class="p">(</span><span class="n">net_mutex</span><span class="p">);</span>
</pre></div>
</div>
<p>Mbed TLS stellt die folgende Funktion bereit um eigene Implementationen der <code class="docutils literal notranslate"><span class="pre">calloc</span></code> und <code class="docutils literal notranslate"><span class="pre">free</span></code> Funktionen innerhalb Mbed TLS zu verwenden:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">mbedtls_platform_set_calloc_free</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">calloc_func</span><span class="p">)(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">size_t</span> <span class="p">),</span>
                                      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free_func</span><span class="p">)(</span> <span class="kt">void</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>Jedoch gilt zu beachten, dass diese Funktion nur aufgerufen werden kann wenn <code class="docutils literal notranslate"><span class="pre">MBEDTLS_PLATFORM_C</span></code> und <code class="docutils literal notranslate"><span class="pre">MBEDTLS_PLATFORM_MEMORY</span></code> definiert sind! Diese wurden in unserem Fall über STM32CubeMX konfiguriert.</p>
<p>Diese Funktion wird in <code class="docutils literal notranslate"><span class="pre">mbedtls.c</span></code> aufgerufen:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;mbedtls.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;mbedtls/platform.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;heap_mem.h&quot;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">MX_MBEDTLS_Init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">mbedtls_platform_set_calloc_free</span><span class="p">(</span><span class="n">rcalloc</span><span class="p">,</span> <span class="n">rfree</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="network-stack">
<h3><span class="section-number">4.3.3. </span>Network Stack<a class="headerlink" href="#network-stack" title="Link zu dieser Überschrift">¶</a></h3>
<p>Um Mbed TLS in den aktuellen LWIP Network Stack einzubringen mussten einige Anpassungen gemacht werden.</p>
<p>LWIP verwendet für die Adressierung der Sockets einen Index.
Dieser Index wird standardmäßig in Mbed TLS nicht richtig adressiert, was dazu führt das alle <code class="docutils literal notranslate"><span class="pre">mbedtls_net_context</span></code> auf den gleichen Socket in LWIP verweisen. Diese Socketverwaltung musste somit selbst implementiert werden.
Dies wurde durch ein einfaches Array umgesetzt:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="n">socks</span><span class="p">[</span><span class="n">MEMP_NUM_NETCONN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">MEMP_NUM_NETCONN</span></code> beschreibt hierbei die Präprozessor für die maximale Anzahl an simultanen Netzwerkverbindungen.<span class="raw-html-m2r"><br></span>
Wenn ein Socketindex aktiv, bzw. reserviert ist wird dieser auf eine Wert der nicht <code class="docutils literal notranslate"><span class="pre">0</span></code> ist (in diesem Fall wird er auf <code class="docutils literal notranslate"><span class="pre">1</span></code> gesetzt).</p>
<p><code class="docutils literal notranslate"><span class="pre">net_sockets.c</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">mbedtls_net_init</span><span class="p">(</span> <span class="n">mbedtls_net_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">xSemaphoreTake</span><span class="p">(</span><span class="n">net_mutex</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pdTRUE</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">lwip_initialized</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">MX_LWIP_Init</span><span class="p">();</span>
        <span class="n">lwip_initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MEMP_NUM_NETCONN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">socks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">socks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">xSemaphoreGive</span><span class="p">(</span><span class="n">net_mutex</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Beim freigeben eines <code class="docutils literal notranslate"><span class="pre">mbedtls_net_context</span></code> wird dessen Socketindex auch wieder auf <code class="docutils literal notranslate"><span class="pre">0</span></code> gesetzt, somit ist dieser wieder frei von einem anderen Socket benutzt zu werden.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">mbedtls_net_free</span><span class="p">(</span> <span class="n">mbedtls_net_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">xSemaphoreTake</span><span class="p">(</span><span class="n">net_mutex</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pdTRUE</span><span class="p">);</span>
    <span class="n">socks</span><span class="p">[</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">xSemaphoreGive</span><span class="p">(</span><span class="n">net_mutex</span><span class="p">);</span>
    <span class="n">shutdown</span><span class="p">(</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
    <span class="n">close</span><span class="p">(</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="p">);</span>

    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Sowohl beim initialisieren als auch beim freigeben wurde Nebenläufigkeit berücksichtig. Um diese problemlose Nebenläufigkeit in unserer eigenen Implementierung zu gewährleisten werden alle kritischen Vorgänge mit einem Mutex, bzw. Semaphore abgesichert. Der Code der das gewährleistet wird unter <a class="reference external" href="#heap-speicher">Heap Speicher</a> erläutert.</p>
</div>
<div class="section" id="modbus">
<h3><span class="section-number">4.3.4. </span>Modbus<a class="headerlink" href="#modbus" title="Link zu dieser Überschrift">¶</a></h3>
<p>Um die TLS Implementierung optional zu halten wurde viel mit Präprozessoren gearbeitet. Wenn eine bestimmte Präprozessor definiert wird werden bestimmte Sektionen an Code ausgeführt, dadurch kann TLS einfach an- bzw. abgeschaltet werden. Zur Veranschaulichung wie das konkret in Code funktioniert dient folgendes Beispiel:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef USE_TLS</span>
<span class="c1">// Code in diesem Bereich wird nur ausgeführt wenn USE_TLS definiert ist.</span>
<span class="cp">#else</span>
<span class="c1">// Code in diesem Bereich wird nur ausgeführt wenn USE_TLS *nicht* definiert ist.</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>Konkret wird diese Präprozessor über die Makefile gesetzt, lediglich nur wenn <code class="docutils literal notranslate"><span class="pre">make</span></code> mit <code class="docutils literal notranslate"><span class="pre">config=tls</span></code> aufgerufen wird.</p>
<p>Generell hat sich strukturell nicht viel geändert zur ursprünglichen Modbus Implementation, es wurden lediglich LWIP Funktionen mit denen von Mbed TLS ersetzt, und wenn <code class="docutils literal notranslate"><span class="pre">USE_TLS</span></code> definiert ist wird zusätzlich der TLS Handshake durchgeführt.</p>
</div>
</div>
<div class="section" id="zertifikate">
<h2><span class="section-number">4.4. </span>Zertifikate<a class="headerlink" href="#zertifikate" title="Link zu dieser Überschrift">¶</a></h2>
<p>In <code class="docutils literal notranslate"><span class="pre">./tools/</span></code> wurde ein Bash Skript mit dem Namen <code class="docutils literal notranslate"><span class="pre">create_new_certs_with_ca.sh</span></code> erstellt.
Dieses Skript erstellt eine CA, sowie alle benötigten Zertifikate.
Zur Erstellung dieser Daten werden von Mbed TLS bereitgestellte Programme verwendet (<code class="docutils literal notranslate"><span class="pre">gen_key</span></code> und <code class="docutils literal notranslate"><span class="pre">cert_write</span></code>). Diese sind als Sourcecode auf GitHub zu finden:
<a class="reference external" href="https://github.com/ARMmbed/mbedtls/tree/development/programs">https://github.com/ARMmbed/mbedtls/tree/development/programs</a></p>
<p>Im Anschluss werden die erstellten Zertifikate mit der CA signiert.
Die CA (Certificate Authority) und ihre signierten Zertifikate werden in Ordnern des <a class="reference external" href="#secure-layer">Secure Layers</a> gespeichert.
Daraufhin werden die für die Remote-IOs benötigten Schlüssel und Zertifikate in eine Makefile exportiert, wodurch beim Bauen der Remote-IO Binaries diese alle benötigten Informationen erhalten.</p>
</div>
<div class="section" id="fazit-und-ausblick">
<h2><span class="section-number">4.5. </span>Fazit und Ausblick<a class="headerlink" href="#fazit-und-ausblick" title="Link zu dieser Überschrift">¶</a></h2>
<!-- evtl. überarbeiten --><div class="section" id="fazit">
<h3><span class="section-number">4.5.1. </span>Fazit<a class="headerlink" href="#fazit" title="Link zu dieser Überschrift">¶</a></h3>
<p>Durch die zusätzlichen Implementierungen kann nun optional zwischen der ursprünglich unverschlüsselten Modbus Verbindung und der durch das TLS-Protokoll verschlüsselten Verbindung ausgewählt werden. Zusätzlich zu der verschlüsselten Verbindung übernimmt das Protokoll auch die Überprüfung der Authentizität der Kommunikationspartner. So muss bei einem Verbindungsaufbau das Remote-IO mit einem Zertifikat belegen, dass dieser dem LICSTER-Netzwerk zugehörig ist.</p>
</div>
<div class="section" id="ausblick">
<h3><span class="section-number">4.5.2. </span>Ausblick<a class="headerlink" href="#ausblick" title="Link zu dieser Überschrift">¶</a></h3>
<p>Nach der durch die Verschlüsselung der Kommunikationswege zwischen dem PLC und der Remote-IOs errungenen Sicherheit kann an der Beschleunigung des TLS-Handshakes gearbeitet werden. Durch verwenden eines Secure Elements kann der momentan sehr langsame Verbindungsaufbau von etwa 10 Sekunden beschleunigt werden. Solch ein Microchip würde zusätzliche Sicherheit mit sich bringen, da die Privat Keys dieser unzugänglich sind. Nach der Verbesserung der Performance des Protokolls könnte die sichere Modbus Verbindung auch auf die weiteren Komponenten (HMI und SCADA) des Netzwerkes ausgeweitet werden. Um eine höhere Authentizität im LICSTER-Netzwerk zu erreichen könnte man die Client Authentifizierung derartig erweitern, dass zusätzlich zu den Remote-IOs auch das PLC mithilfe von Zertifikaten seine Zugehörigkeit bestätigen muss.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="webapp.html" class="btn btn-neutral float-right" title="5. Webapplikation Backend" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ids.html" class="btn btn-neutral float-left" title="3. Intrusion Detection System" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Fabian Klemm, Eric Hoffmann, Raphael Hausmanninger, Michael Janzer, Muhammet Bilbey, Athanasios Luludis, Janis Schickram

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>