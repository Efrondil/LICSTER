

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="de" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="de" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>3. Intrusion Detection System &mdash; LICSTER 2020 Dokumentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Stichwortverzeichnis" href="genindex.html" />
    <link rel="search" title="Suche" href="search.html" />
    <link rel="next" title="4. Secure Communication" href="seccom.html" />
    <link rel="prev" title="2. Workflow" href="kommunikation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> LICSTER
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="einleitung.html">1. Einleitung</a></li>
<li class="toctree-l1"><a class="reference internal" href="kommunikation.html">2. Workflow</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">3. Intrusion Detection System</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#unser-team">3.1. Unser Team</a></li>
<li class="toctree-l2"><a class="reference internal" href="#einrichtung-pi">3.2. Einrichtung Pi</a></li>
<li class="toctree-l2"><a class="reference internal" href="#einrichtung-vm">3.3. Einrichtung VM</a></li>
<li class="toctree-l2"><a class="reference internal" href="#was-ist-ein-ids">3.4. Was ist ein IDS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#wieso-man-es-braucht">3.5. Wieso man es braucht</a></li>
<li class="toctree-l2"><a class="reference internal" href="#arten-von-ids">3.6. Arten von IDS</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#signature-based-detection">3.6.1. Signature-based detection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#anomaly-based-detection">3.6.2. Anomaly-based detection</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#wireshark">3.7. Wireshark</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#durchgefuhrte-angriffe">3.7.1. Durchgeführte Angriffe</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#flooding">3.7.1.1. Flooding</a></li>
<li class="toctree-l4"><a class="reference internal" href="#angriff-auf-das-flieszband">3.7.1.2. Angriff auf das Fließband</a></li>
<li class="toctree-l4"><a class="reference internal" href="#angriff-auf-die-manuelle-kontrolle">3.7.1.3. Angriff auf die manuelle Kontrolle</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#snort">3.8. Snort</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#wieso-snort">3.8.1. Wieso Snort?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#snort-einrichtung">3.8.2. Snort Einrichtung</a></li>
<li class="toctree-l3"><a class="reference internal" href="#snort-regeln">3.8.3. Snort Regeln</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#regel-schreiben">3.8.3.1. Regel schreiben</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aktion">3.8.3.2. Aktion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kopf">3.8.3.3. Kopf</a></li>
<li class="toctree-l4"><a class="reference internal" href="#regeloptionen">3.8.3.4. Regeloptionen</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#unsere-snort-regeln">3.9. Unsere Snort Regeln</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#http-regeln">3.9.1. HTTP Regeln</a></li>
<li class="toctree-l3"><a class="reference internal" href="#icmp-regel">3.9.2. ICMP Regel</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modbus-regel">3.9.3. Modbus Regel</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ssh-regel">3.9.4. SSH Regel</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fazit-und-ausblick">3.10. Fazit und Ausblick</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#fazit">3.10.1. Fazit</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ausblick">3.10.2. Ausblick</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="seccom.html">4. Secure Communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="webapp.html">5. Webapplikation</a></li>
<li class="toctree-l1"><a class="reference internal" href="probleme.html">6. Probleme</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">LICSTER</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li><span class="section-number">3. </span>Intrusion Detection System</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/ids.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="intrusion-detection-system">
<h1><span class="section-number">3. </span>Intrusion Detection System<a class="headerlink" href="#intrusion-detection-system" title="Link zu dieser Überschrift">¶</a></h1>
<p>In unserer heutigen Zeit nehmen Angriffe auf industriele Systeme stetig weiter zu.
Immer wieder werden neue arten gefunden wie ein System angegriffen werden kann.
Dementsprechend gibt es auch schon sehr viele verschieden Tools die dafür da sind um
zu erkennenden wenn ein Angriff oder ein exploit auf einem System ausgeführt wird und
diesen dann auch dementsprechend zu stoppen:  Software wie Firewalls verhindern dass
nicht autorisierter Datenverkehr in das Netzwerk gelangt, Spam-Filter um unerwünschte
E-Mail-Nachrichten zu verhindern und Antiware-Tools zum Schutz von Endpunkten vor Malware.
All diese Tools werden in so gut wie jedem Unternehmen eingesetzt egal welche Branche
oder wie groß es ist. Ein weiteres wertvolles Sicherheitstool was ebenfalls eingesetzt
wird ist ein Netzwerk-IDS (Intrusion Detection-System). Um dieses geht es auch in unserem
Teil Projekt, bei dem wir ein solches System in dem Testbed LICSTER implementiert haben.</p>
<div class="section" id="unser-team">
<h2><span class="section-number">3.1. </span>Unser Team<a class="headerlink" href="#unser-team" title="Link zu dieser Überschrift">¶</a></h2>
<p>Unser Team für das Teilprojekt „Intrusion Detection System“ (IDS) besteht aus den Projektmitgliedern Eric Hoffmann, Michael Janzer und Janis Schickram, die auch schon in ihrem Studium einen starken Fokus auf IT-Sicherheit gelegt haben. Wir haben zusammen mehrerer Kurse in Richtung IT-Sicherheit besucht und teilen uns die Faszination Systeme sicherer machen zu wollen. Deswegen wurde schnell klar, dass unser Team einen großen Wert auf den Sicherheitsaspekt von LICSTER legen wird.
Die Sicherheitslage von Industriesystemen auf der ganzen Welt wird immer kritischer. Bei Angriffen auf diese Systeme können in kürzester Zeit große wirtschaftliche Schäden erzielt werden.</p>
<div class="figure align-default" id="id1">
<img alt="_images/cyberattacken_excel.png" src="_images/cyberattacken_excel.png" />
<p class="caption"><span class="caption-number">Abb. 3.1.1 </span><span class="caption-text">Cyberattacken auf deutsche Unternehmen im Jahre 2015,
Quelle: <a class="reference external" href="https://de.statista.com/statistik/daten/studie/348989/umfrage/haeufigkeit-von-cyberattacken-auf-unternehmen/">https://de.statista.com/statistik/daten/studie/348989/umfrage/haeufigkeit-von-cyberattacken-auf-unternehmen/</a>, Zugriff am 15.07.2020</span><a class="headerlink" href="#id1" title="Link zu diesem Bild">¶</a></p>
</div>
<p>Deswegen haben wir uns zur Aufgabe gemacht, LICSTER eine weitere Sicherheitsschicht hinzuzufügen. Schnell wurde klar, dass ein IDS eine schnelle und aufwandseffiziente Lösung für unsere Problemstellung ist. Ein IDS kann in ein bestehendes System eingebaut werden, ohne dass direkte Änderungen am System gemacht werden müssen. Dies war uns besonders wichtig, da LICSTER bereits vor unserem Projekt schon fertiggestellt war und wir keine konzeptuelle Änderung mehr nachträglich realisieren wollten. Ein bestehendes IDS zu Nutzen hat es uns ermöglicht den zeitlichen Rahmen des Projekts einzuhalten und nützliche Fähigkeiten für unser weiteres Studium zu erlernen.</p>
</div>
<div class="section" id="einrichtung-pi">
<h2><span class="section-number">3.2. </span>Einrichtung Pi<a class="headerlink" href="#einrichtung-pi" title="Link zu dieser Überschrift">¶</a></h2>
<p>Für die Realisierung des IDS wurde sich für ein Raspberry Pi 4 entschieden. Mit 4 GB RAM - in der ausgewälten Konfiguration - ist das Pi geeignet Snort als IDS zu verwenden. Als Betriebssystem wird das Raspberry Pi OS (früher Raspbian genannt) genutzt, welches von der offiziellen Seite bezogen wurde (<a class="reference external" href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a>). Dies wurde mit einem Image-Tool auf eine SD-Karte gespielt und über SSH wurden dann die restlichen Einrichtungen vorgenommen. Nachdem alles eingerichtet war, konnte das Pi in das LICSTER Netzwerk eingesetzt werden. Das Pi wurde an den Mirrorport des Switchs angeschlossen, damit der gesamte Traffic des LICSTERs am Pi empfangen werden kann. Um durch den Dauerbetrieb entstehende Abwärme entgegenzuwirken wurde eine Hülle mit Lüftern für das Pi angeschafft. Im Home-Verzeichnis wurde das Git aus GitLab gecloned. Dieses Repository enthält die Configs und Rules für Snort, sowie weitere Skripte für das IDS.</p>
<div class="figure align-default" id="id2">
<img alt="_images/Rapsberry_IDS_Showcase.jpg" src="_images/Rapsberry_IDS_Showcase.jpg" />
<p class="caption"><span class="caption-number">Abb. 3.2.1 </span><span class="caption-text">Unser IDS-Raspberry</span><a class="headerlink" href="#id2" title="Link zu diesem Bild">¶</a></p>
</div>
</div>
<div class="section" id="einrichtung-vm">
<h2><span class="section-number">3.3. </span>Einrichtung VM<a class="headerlink" href="#einrichtung-vm" title="Link zu dieser Überschrift">¶</a></h2>
<p>Aus Kostengründen konnte nicht für jedes der drei Mitglieder ein Raspberry Pi gekauft werden. Dieses Problem wurde mit Virtuellen Maschinen gelöst. Virtuelle Maschinen emulieren Hardware als Software auf einem Hostsystem. Als Virtualisierungssoftware wurde VirtualBox verwendet welches ein Image des Raspberry Pi Desktops nutzte. Somit konnte jedes Mitglied seine eigenes Raspberry Pi simulieren und jede Aufgabe konnte von Jedem erledigt werden. Bei der Einrichtung des Betriebssystems musste auf die bautechnischen Beschränkungen des Raspberry Pi 4 geachtet werden. Somit musste in der VM der Hauptspeicher auf 4 GB RAM beschränkt und der Festplattenspeicher musste auf die 64 GB der eingebauten SD-Karte begrenzt werden.</p>
</div>
<div class="section" id="was-ist-ein-ids">
<h2><span class="section-number">3.4. </span>Was ist ein IDS<a class="headerlink" href="#was-ist-ein-ids" title="Link zu dieser Überschrift">¶</a></h2>
<p>„Ein IDS (Intrusion Detection System) ist ein Gerät oder eine Anwendung,
mit der der gesamte Netzwerkverkehr überprüft und der Benutzer oder Administrator
benachrichtigt wird, wenn nicht autorisierte Versuche oder Zugriffe stattgefunden haben.“ (Bradley, T., 2014. IDS. [online] verfügbar unter: <a class="reference external" href="https://techspective.net/2014/03/08/ids/">https://techspective.net/2014/03/08/ids/</a> [Besucht 12 July 2020].)
Im Gegensatz dazu steht die Firewall, welche meist als Gatekeeper fungiert und somit nur den
Netzwerkverkehr überwacht und regelt. Das IDS konzentriert sich
auf den Traffic, der im internen Netzwerk abläuft. Dabei wird anhand von
verschieden Rulesets entschieden, ob der Traffic verdächtig ist bzw. er sich ungewöhnlich
verhält. Beispielhaft hierzu wäre es, wenn ein plötzlicher Anstieg des Traffic im Netzwerk erkannt wird.
Durch diese Weise kann ein IDS Angriffe erkennen welche an der Firewall
vorbei kommen oder aus dem eigenem Netzwerk stammen.</p>
</div>
<div class="section" id="wieso-man-es-braucht">
<h2><span class="section-number">3.5. </span>Wieso man es braucht<a class="headerlink" href="#wieso-man-es-braucht" title="Link zu dieser Überschrift">¶</a></h2>
<p>Keine Firewall ist fehlerfrei und kein Netzwerk ist undurchdringlich. Angreifer
entwickeln ständig neue Exploits und Angriffstechniken, um auf ein System zu kommen.
Was von vielen Angreifern zusätzlich gerne genutzt wird ist Social Engineering oder
andere arten von Malware. Über diese Methoden gelangen sie meist an Benutzeranmeldeinformationen
und dadurch haben sie nun einen berechtigten zugriff auf das Netzwerk ohne das die
Firewall dies als böswilligen angriff sieht. Ein Network Intrusion Detection System kann
dagegen immer noch sehe was die Person auf dem System macht und falls dabei nun versucht
wird das irgendwelche angriffe ausgeführt werden diese auch erkennen und den System
Administrator zu benachrichtigen das dort was im System nicht stimmt.</p>
<p>Der Haupt Zweck eines ids systems besteht somit darin das It-Personal zu benachrichtigen
falls es einen Angriff oder andere Arten von Bad traffic gefunden hat. Die Kunst für das
Personal besteht nun darin zu schauen welche nachrichtig stimmen und welche ein false
positiv sind.</p>
</div>
<div class="section" id="arten-von-ids">
<h2><span class="section-number">3.6. </span>Arten von IDS<a class="headerlink" href="#arten-von-ids" title="Link zu dieser Überschrift">¶</a></h2>
<p>Im Grundlegen werden zwischen zwei Arten von ids Systemen unterschieden nämlich der signature-based detection
und der anomaly-based detection.</p>
<div class="section" id="signature-based-detection">
<h3><span class="section-number">3.6.1. </span>Signature-based detection<a class="headerlink" href="#signature-based-detection" title="Link zu dieser Überschrift">¶</a></h3>
<p>Bei dieser Methode werden feste Muster verwendet, um den traffic zu kontrollieren.
Diese Muster beschreiben verdächtige Sammlung von Abfolgen von Aktivitäten oder
Operationen, die möglicherweise schädlich sein können. Diese werden dann meist in einer
Datenbank gespeichert. Es werden somit genau definierte Angriffsmuster verwendet,
die die Schwachstelen im System ausnutzten. Die Zeit, die somit gebraucht wird, um den
traffic zu vergleichen ist minimal. Der Hauptvorteil besteht somit darin das Muster oder
Signaturen das Netzwerkverhalten leicht verstehen zu können. Es ist somit effizienter
Angriffe zu verarbeiten die schon bekannt sind.</p>
<p>Die Hauptbeschränkung dieses Systems ist dadurch das Reagieren und Erkennen von Angriffen,
die nicht in der Datenbank gespeichert sind. Somit kann dieses System leicht getäuscht
werden das es nur mit einem bestimmten Satz von ausdrücken oder mit Zeichenfolgenübereinstimmung
arbeiten. Desweitern tuen sich solches System sehr schwer mit Angriffen bei denen
Menschen aktiv etwas tun.</p>
</div>
<div class="section" id="anomaly-based-detection">
<h3><span class="section-number">3.6.2. </span>Anomaly-based detection<a class="headerlink" href="#anomaly-based-detection" title="Link zu dieser Überschrift">¶</a></h3>
<p>Bei diesem System ist das Netzwerkverhalten der Haupt Parameter. Deshalb wird vorerst ein
Model erstellt, welches zeigt wie der normale traffic im Netzwerk aussehen soll.
Dieser kann entweder vorbestimmt werden oder durch vom Netzwerkadministrator festgelegte
Spezifikationen oder Bedingungen mit machine learning gelernt werden. Wenn das
Netzwerkverhalten innerhalb des Models liegt passt alles falls nicht wir eine Wahrung
vom Anomaly detection system ausgelöst.</p>
<p>Das Definieren der Regelsätze ist einer der Hauptnachteile des Anomaly detection systems.
Die Effizienz des Systems hängt von der effektiven Implementierung und dem Testen von
Regelsätzen für alle Protokolle ab. Darüber hinaus wirken sich verschiedene Protokolle
verschieden stark auf das System aus. Des Weiteren hat das System Probleme dabei wen das
böswillige Verhalten unter das akzeptierende Verhalten fällt.</p>
</div>
</div>
<div class="section" id="wireshark">
<h2><span class="section-number">3.7. </span>Wireshark<a class="headerlink" href="#wireshark" title="Link zu dieser Überschrift">¶</a></h2>
<p>Um einen Überblick über die Pakete, die im LICSTER Netzwerk unterwegs sind, zu
bekommen, haben wir, mit Wireshark, den Netzwerkverkehr aufgezeichnet.</p>
<p>Als erstes haben wir pcaps während dem Einschalten, Betrieb und Abschalten von dem Testbed, mithilfe des Mirror Ports erstellt,
um zu sehen was während einem Regulären betrieb auf dem Netzwerk passiert.</p>
<div class="figure align-default" id="id3">
<img alt="_images/wireshark_normal.png" src="_images/wireshark_normal.png" />
<p class="caption"><span class="caption-number">Abb. 3.7.1 </span><span class="caption-text">Wireshark pcap vom LICSTER-Testbed während einem Leerlauf</span><a class="headerlink" href="#id3" title="Link zu diesem Bild">¶</a></p>
</div>
<p>Als nächstes haben wir pcaps von Angriffen, die wir Durchgeführt haben, aufgezeichnet, um Regeln für unser Intrusion-Detection-System entwickeln zu können.</p>
<div class="figure align-default" id="id4">
<img alt="_images/wireshark_flood.png" src="_images/wireshark_flood.png" />
<p class="caption"><span class="caption-number">Abb. 3.7.2 </span><span class="caption-text">Wireshark pcap vom LICSTER-Testbed während einem Denial of Service Angriffs</span><a class="headerlink" href="#id4" title="Link zu diesem Bild">¶</a></p>
</div>
<div class="section" id="durchgefuhrte-angriffe">
<h3><span class="section-number">3.7.1. </span>Durchgeführte Angriffe<a class="headerlink" href="#durchgefuhrte-angriffe" title="Link zu dieser Überschrift">¶</a></h3>
<p>Die Skripte für die Angriffe sind im Offiziellen Github Repository zu finden (<a class="reference external" href="https://github.com/hsainnos/LICSTER/tree/master/attacks">https://github.com/hsainnos/LICSTER/tree/master/attacks</a>).</p>
<div class="section" id="flooding">
<h4><span class="section-number">3.7.1.1. </span>Flooding<a class="headerlink" href="#flooding" title="Link zu dieser Überschrift">¶</a></h4>
<p>Flooding ist eine einfache und beliebte Art eines Denial-of-Service Angriffs.
Für den Angriff haben wir hping3 benutzt. Ein Einfaches CLI-tool um Pakete zu versenden.</p>
<p>Hier wird eins der beiden RemoteIO’s vom LICSTER Testbed geflutet.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ sudo hping3 --flood 192.168.0.51
</pre></div>
</div>
</div>
<div class="section" id="angriff-auf-das-flieszband">
<h4><span class="section-number">3.7.1.2. </span>Angriff auf das Fließband<a class="headerlink" href="#angriff-auf-das-flieszband" title="Link zu dieser Überschrift">¶</a></h4>
<p>Hier haben wir mit einem kleinen Python-Skript das Fließband vom LICSTER Testbed angegriffen und zum stoppen gebracht.
Ausgeführt wird er mit:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ sudo ./conveyer_belt.py
</pre></div>
</div>
</div>
<div class="section" id="angriff-auf-die-manuelle-kontrolle">
<h4><span class="section-number">3.7.1.3. </span>Angriff auf die manuelle Kontrolle<a class="headerlink" href="#angriff-auf-die-manuelle-kontrolle" title="Link zu dieser Überschrift">¶</a></h4>
<p>Hier wird, mit einem Python-Skript, die manuelle Kontrolle vom LICSTER Testbed übernommen.
Ausgeführt wird er mit:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ python3 -i client.py
&gt;&gt;&gt;
</pre></div>
</div>
<p>Anschließend kann man dann Befehle senden um das Testbed zu steuern.</p>
</div>
</div>
</div>
<div class="section" id="snort">
<h2><span class="section-number">3.8. </span>Snort<a class="headerlink" href="#snort" title="Link zu dieser Überschrift">¶</a></h2>
<div class="section" id="wieso-snort">
<h3><span class="section-number">3.8.1. </span>Wieso Snort?<a class="headerlink" href="#wieso-snort" title="Link zu dieser Überschrift">¶</a></h3>
<p>Es wurde sich für Snort entschieden, da es schon seit längerem auf dem Markt verfügbar ist. Dank dieser Zeit ist Snort sehr ausgereift und auch weit verbreitet. Es ist kostenlos und durch seine große Community ist es leicht bei Problemen Unterstützung zu bekommen. Ein weiterer Punkt, warum sich für Snort entschieden wurde, ist, dass bereits einige Gruppenmitglieder sich ein wenig mit den Regeln auskannten. Die Syntax der Regeln ist leicht zu verstehen, bieten aber dennoch die nötige Komplexität, um aussagekräftige Meldungen zu bekommen.</p>
</div>
<div class="section" id="snort-einrichtung">
<h3><span class="section-number">3.8.2. </span>Snort Einrichtung<a class="headerlink" href="#snort-einrichtung" title="Link zu dieser Überschrift">¶</a></h3>
<p>Als Erstes hat jedes Gruppenmitglied Snort bei seiner eigenen VM eingerichtet. So konnten schon die ersten Erfahrungen mit den Regeln und der Funktion von Snort gesammelt werden. Dann wurde abgewogen, welche Snort Version am geeignetsten für das Vorhaben ist. Zur Auswahl standen v2 und v3. Die neuere Version v3 besitzt neue Funktionen, aber dies kommt auch mit Performanceeinbußen einher. Da das Raspberry Pi 4 nur begrenzte Rechenleistung und Hauptspeicher besitzt, wurde sich für die ausgereiftere v2 entschieden. Snort wurde über apt install snort bezogen und war dann auch bereit für den Einsatz. Um die gleichen Konfigurationen und Regeln zu haben, wurde ein GitLab Repository eingerichtet welches alle Konfigurationsdateien und Regeln beinhaltet. Somit musste, um Snort zu starten, nur noch der Pfad zu der Konfiguration angegeben werden. Diese Konfigurationsdatei beinhaltete wiederrum die relativen Pfade zu den Regeln im Repository. Nach der Einrichtung sieht der Befehl zum Starten von Snort so aus: sudo snort -c /path/to/snort.conf</p>
</div>
<div class="section" id="snort-regeln">
<h3><span class="section-number">3.8.3. </span>Snort Regeln<a class="headerlink" href="#snort-regeln" title="Link zu dieser Überschrift">¶</a></h3>
<p>Damit Snort Angriffe/Abnormalitäten erkennen kann, müssen Regeln vorhanden sein, wonach Snort sich richten kann. Darauf Achten sollte man, dass man nicht zu viele Regeln implementiert, denn so kann es passieren, das Snort zu viele Alarme wirft, von denen viele  falsch sind und der echte Alarm untergeht (Man sieht den Angriff vor lauter „Angriffe“ nicht mehr). Hat man aber zu wenige Regel implementiert, kann es passieren, dass mögliche Angriffe nicht erkannt werden. Es müssen also so wenig Regeln wie möglich, aber so viele wie nötig implementiert werden um Fehlalarme zu vermeiden und dennoch echte Angriffe erkennen zu können.</p>
<div class="section" id="regel-schreiben">
<h4><span class="section-number">3.8.3.1. </span>Regel schreiben<a class="headerlink" href="#regel-schreiben" title="Link zu dieser Überschrift">¶</a></h4>
<p>Damit man Regeln schreiben kann muss man erst verstehen wie eine Regel
aufgebaut ist. Hier Hilft die offizielle Anleitung
(<a class="reference external" href="http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node27.html">http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node27.html</a>).</p>
<p>Hier in Kurzfassung:</p>
<p>Eine Regel besteht aus drei Teilen:</p>
<ul class="simple">
<li><p>Aktion</p></li>
<li><p>Kopf</p></li>
<li><p>Regeloptionen</p></li>
</ul>
</div>
<div class="section" id="aktion">
<h4><span class="section-number">3.8.3.2. </span>Aktion<a class="headerlink" href="#aktion" title="Link zu dieser Überschrift">¶</a></h4>
<p>Hier wird angegeben was Snort tun soll, wenn es ein Paket findet, das den
Regel Kriterien entspricht. Es gibt 3 verfügbare Standardaktionen in Snort,
alert, log und pass. Wenn Snort im inline-modus ausgeführt wird, stehen drop,
reject und sdrop zur verfügung.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'alert'</span></code> erzeugt einen Alarm mit der gewählten Alarm Methode und protokolliert dann das Paket</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'log'</span></code> das Paket protokollieren</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'pass'</span></code> das Paket ignorieren</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'drop'</span></code> das Paket blockieren und protokollieren</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'reject'</span></code> das Paket blockieren, protokollieren und senden eines TCP-Reset, wenn das Protokoll TCP ist, oder eine ICMP-Port-Unerreichbarkeit Meldung, wenn das Protokoll UDP ist.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'sdrop'</span></code> das Paket blockieren, aber nicht protokollieren</p></li>
</ul>
</div>
<div class="section" id="kopf">
<h4><span class="section-number">3.8.3.3. </span>Kopf<a class="headerlink" href="#kopf" title="Link zu dieser Überschrift">¶</a></h4>
<p>Dieses Feld steht für das Protokoll, die IP Adresse, die Ports und die
Richtungsanweisung.</p>
<p><strong>Protokolle</strong></p>
<p>Es gibt vier Protokolle, die Snort auf verdächtiges Verhalten analysiert: TCP,
UDP, ICMP und IP.</p>
<p><strong>IP Adressen und Ports</strong></p>
<p>Der nächste Teil des Regelkopfes befasst sich mit der IP-Adresse und den Port
für eine bestimmte Regel. Man kann das Heimnetzwerk in der Konfigurationsdatei
von Snort festlegen. Das Schlüsselwort any kann zur Definition einer beliebigen
Adresse verwendet werden.</p>
</div>
<div class="section" id="regeloptionen">
<h4><span class="section-number">3.8.3.4. </span>Regeloptionen<a class="headerlink" href="#regeloptionen" title="Link zu dieser Überschrift">¶</a></h4>
<p>Alle Regeloptionen werden durch das Semikolon (;) voneinander getrennt.
Es gibt vier Kategorien von Regeloptionen:</p>
<ul class="simple">
<li><p>general: enthält extra Informationen über die Regel, haben aber keine auswirkung während der Erkennung</p></li>
<li><p>payload: diese Optionen schauen in den Packet-Payload rein</p></li>
<li><p>non-payload: diese Optionen schauen für nicht payload Daten</p></li>
<li><p>post-detection: diese Optionen sind Regelspezifische trigger, die ausgeführt werden, nachdem eine Regel ausgelöst wird</p></li>
</ul>
<div class="figure align-default" id="id5">
<img alt="_images/rules.png" src="_images/rules.png" />
<p class="caption"><span class="caption-number">Abb. 3.8.1 </span><span class="caption-text">Aufbau einer Beispielregel</span><a class="headerlink" href="#id5" title="Link zu diesem Bild">¶</a></p>
</div>
<p>Eine komplette Auflistung von Regeloptionen:
<a class="reference external" href="http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node32.html">http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node32.html</a></p>
</div>
</div>
</div>
<div class="section" id="unsere-snort-regeln">
<h2><span class="section-number">3.9. </span>Unsere Snort Regeln<a class="headerlink" href="#unsere-snort-regeln" title="Link zu dieser Überschrift">¶</a></h2>
<div class="section" id="http-regeln">
<h3><span class="section-number">3.9.1. </span>HTTP Regeln<a class="headerlink" href="#http-regeln" title="Link zu dieser Überschrift">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>alert tcp !$HOME_NET any -&gt; 192.168.0.10 $HTTP_PORTS (msg:&quot;HTTP Get from EXTERNAL to 192.168.0.10&quot;; \
classtype: bad-unknown; content: &quot;HTTP&quot;; sid 1002000; rev: 1;)
</pre></div>
</div>
<p>Diese Regel ist dafür da, falls von einem Außenstehenden Netzwerk ein HTTP GET request empfangen worden ist.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>alert tcp !192.168.20 any -&gt; 192.168.30 $HTTP_PORTS (msg:&quot;HTTP Get not from 192.168.0.20 to 192.168.0.30&quot;; \
classtype: bad-unknown; content: &quot;HTTP&quot;; sid 1002005; rev: 1;)
</pre></div>
</div>
<p>Hier ähnlich wie bei der vorherigen Regel, nur wird hier der Alarm geworfen, falls das GET request vom Heimnetz, aber nicht vom HMI, kommt.</p>
</div>
<div class="section" id="icmp-regel">
<h3><span class="section-number">3.9.2. </span>ICMP Regel<a class="headerlink" href="#icmp-regel" title="Link zu dieser Überschrift">¶</a></h3>
<p><strong>Portscan</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alert</span> <span class="n">icmp</span> <span class="nb">any</span> <span class="nb">any</span> <span class="o">-&gt;</span> <span class="mf">192.168</span><span class="o">.</span><span class="mf">0.10</span> <span class="nb">any</span> <span class="p">(</span><span class="n">msg</span><span class="p">:</span><span class="s2">&quot;Ping nmap Portscan 192.168.0.10&quot;</span><span class="p">;</span> \
<span class="n">dsize</span><span class="p">:</span><span class="mi">0</span><span class="p">;</span> <span class="n">itype</span><span class="p">:</span><span class="mi">8</span><span class="p">;</span> <span class="n">classtype</span><span class="p">:</span> <span class="n">network</span><span class="o">-</span><span class="n">scan</span><span class="p">;</span> <span class="n">sid</span><span class="p">:</span><span class="mi">1003000</span><span class="p">;</span> <span class="n">rev</span><span class="p">:</span><span class="mi">1</span><span class="p">;)</span>
</pre></div>
</div>
<p>ICMP-Fehlermeldungen (Protocol/Port Unreachable) können verwendet werden, um die offenen Ports zu einer IP-Adresse herauszufinden.
Da die Paketgröße 0 ist wird hier <code class="docutils literal notranslate"><span class="pre">'dsize'</span></code> auf 0 gesetzt und der <code class="docutils literal notranslate"><span class="pre">'itype'</span></code> auf 8, da der Typ 8 für Echo Request steht.</p>
<p><strong>DoS</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alert</span> <span class="n">icmp</span> <span class="nb">any</span> <span class="nb">any</span> <span class="o">-&gt;</span> <span class="mf">192.168</span><span class="o">.</span><span class="mf">0.10</span> <span class="nb">any</span> <span class="p">(</span><span class="n">msg</span><span class="p">:</span><span class="s2">&quot;Ping flood detected 192.168.0.10&quot;</span><span class="p">;</span> \
<span class="n">itype</span><span class="p">:</span><span class="mi">8</span><span class="p">;</span> <span class="n">count</span> <span class="mi">20</span><span class="p">,</span> <span class="n">seconds</span> <span class="mi">1</span><span class="p">;</span> <span class="n">classtype</span><span class="p">:</span> <span class="n">denial</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">service</span><span class="p">;</span> <span class="n">sid</span><span class="p">:</span><span class="mi">1003010</span><span class="p">;</span> <span class="n">rev</span><span class="p">:</span><span class="mi">1</span><span class="p">;)</span>
</pre></div>
</div>
<p>Diese Regel ist für einen einfachen Ping flood Denial-of-Service Angriff. Ausgelöst wird die Regel, wenn
in einem Intervall von einer Sekunde, 20 Ping Pakete ankommen.</p>
<p><strong>DoS Teardrop</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alert</span> <span class="n">icmp</span> <span class="nb">any</span> <span class="nb">any</span> <span class="o">-&gt;</span> <span class="mf">192.168</span><span class="o">.</span><span class="mf">0.10</span> <span class="nb">any</span> <span class="p">(</span><span class="n">msg</span><span class="p">:</span><span class="s2">&quot;ICMP Teardrop attack 192.168.0.10&quot;</span><span class="p">;</span> \
<span class="n">fragbits</span><span class="p">:</span><span class="n">M</span><span class="p">;</span> <span class="n">classtype</span><span class="p">:</span> <span class="n">denial</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">service</span><span class="p">;</span> <span class="n">sid</span><span class="p">:</span><span class="mi">1003020</span><span class="p">;</span><span class="n">rev</span><span class="p">:</span><span class="mi">1</span><span class="p">;)</span>
</pre></div>
</div>
<p>Teardrop-Angriffe senden Fragmentierte Pakete die nicht wieder zusammengesetzt werden können, das zu einem DoS führen kann. Um den Angriff zu erkennen,
wird hier <code class="docutils literal notranslate"><span class="pre">'fragbits'</span></code> auf <code class="docutils literal notranslate"><span class="pre">'M'</span></code> für more gesetzt, was heißt dass noch mehr Pakete kommen.</p>
<p><strong>ICMP Router Discovery</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alert</span> <span class="n">icmp</span> <span class="nb">any</span> <span class="nb">any</span> <span class="o">-&gt;</span> <span class="mf">192.168</span><span class="o">.</span><span class="mf">0.10</span> <span class="nb">any</span> <span class="p">(</span><span class="n">msg</span><span class="p">:</span><span class="s2">&quot;ICMP Router Discovery 192.168.0.10&quot;</span><span class="p">;</span> \
<span class="n">icode</span><span class="p">:</span><span class="mi">0</span><span class="p">;</span> <span class="n">itype</span><span class="p">:</span><span class="mi">9</span><span class="p">;</span> <span class="n">classtype</span><span class="p">:</span> <span class="n">network</span><span class="o">-</span><span class="n">scan</span><span class="p">;</span> <span class="n">sid</span><span class="p">:</span><span class="mi">1003030</span><span class="p">;</span> <span class="n">rev</span><span class="p">:</span><span class="mi">1</span><span class="p">;)</span>
</pre></div>
</div>
<p>Ähnlich wie beim Portscan, nur werden hier nach Benachbarten Routern gesucht. <code class="docutils literal notranslate"><span class="pre">'itype'</span></code> wird auf 9 gesetzt da es für Router Advertisement steht.</p>
<p><strong>ICMP Too large packet</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alert</span> <span class="n">icmp</span> <span class="nb">any</span> <span class="nb">any</span> <span class="o">-&gt;</span> <span class="mf">192.168</span><span class="o">.</span><span class="mf">0.10</span> <span class="nb">any</span> <span class="p">(</span><span class="n">msg</span><span class="p">:</span><span class="s2">&quot;Large ICMP Packet 192.168.0.10&quot;</span><span class="p">;</span> \
<span class="n">dsize</span><span class="p">:</span><span class="o">&gt;</span><span class="mi">1500</span><span class="p">;</span> <span class="n">classtype</span><span class="p">:</span> <span class="n">denial</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">service</span><span class="p">;</span> <span class="n">sid</span><span class="p">:</span><span class="mi">1003040</span><span class="p">;</span> <span class="n">rev</span><span class="p">:</span><span class="mi">1</span><span class="p">;)</span>
</pre></div>
</div>
<p>Diese Regel ist dafür da, falls zu große ICMP Pakete gesendet werden. <code class="docutils literal notranslate"><span class="pre">'dsize'</span></code> ist für die Paketgröße und wurde hier auf größer 1500 gesetzt.</p>
</div>
<div class="section" id="modbus-regel">
<h3><span class="section-number">3.9.3. </span>Modbus Regel<a class="headerlink" href="#modbus-regel" title="Link zu dieser Überschrift">¶</a></h3>
<p><strong>DoS</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alert</span> <span class="n">tcp</span> <span class="nb">any</span> <span class="nb">any</span> <span class="o">-&gt;</span> <span class="mf">192.168</span><span class="o">.</span><span class="mf">0.51</span> <span class="mi">502</span> <span class="p">(</span><span class="n">msg</span><span class="p">:</span><span class="s2">&quot;Modbus threshold violation 51&quot;</span><span class="p">;</span> <span class="n">threshold</span><span class="p">:</span> \
<span class="nb">type</span> <span class="n">both</span><span class="p">,</span> <span class="n">track</span> <span class="n">by_dst</span><span class="p">,</span> <span class="n">count</span> <span class="mi">60</span><span class="p">,</span> <span class="n">seconds</span> <span class="mi">1</span><span class="p">;</span> <span class="n">classtype</span><span class="p">:</span> <span class="n">successful</span><span class="o">-</span><span class="n">dos</span><span class="p">;</span> <span class="n">sid</span><span class="p">:</span><span class="mi">1001004</span><span class="p">;)</span>
</pre></div>
</div>
<p>Diese Regel erkennt einen Denial-of-Service Angriff über das Modbus.</p>
</div>
<div class="section" id="ssh-regel">
<h3><span class="section-number">3.9.4. </span>SSH Regel<a class="headerlink" href="#ssh-regel" title="Link zu dieser Überschrift">¶</a></h3>
<p><strong>Strange Traffic</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>alert tcp !$HOME_NET any -&gt; 192.168.0.10 22 (msg:&quot;SSH Request from EXTERNAL NET to 192.168.0.10&quot;; \
content:&quot;SSH&quot;; nocase; offset:0; depth:4; classtype: attempted-user; sid:1000101; rev:1;)
</pre></div>
</div>
<p>Diese Regel erkennt einen SSH Zugriffs versuch aus einem externen Netz.</p>
<p><strong>Brute Force</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alert</span> <span class="n">tcp</span> <span class="nb">any</span> <span class="nb">any</span> <span class="o">-&gt;</span> <span class="nb">any</span> <span class="mi">22</span> <span class="p">(</span><span class="n">msg</span><span class="p">:</span><span class="s2">&quot;SSH Brute Force Attempt&quot;</span><span class="p">;</span> <span class="n">flow</span><span class="p">:</span><span class="n">established</span><span class="p">,</span> <span class="n">to_server</span><span class="p">;</span> <span class="n">content</span><span class="p">:</span><span class="s2">&quot;SSH&quot;</span><span class="p">;</span> \
<span class="n">nocase</span><span class="p">;</span> <span class="n">offset</span><span class="p">:</span><span class="mi">0</span><span class="p">;</span> <span class="n">depth</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span> <span class="n">detection_filter</span><span class="p">:</span><span class="n">track</span> <span class="n">by_src</span><span class="p">,</span> <span class="n">count</span> <span class="mi">30</span><span class="p">,</span> <span class="n">seconds</span> <span class="mi">1</span><span class="p">;</span> <span class="n">classtype</span><span class="p">:</span> <span class="n">attempted</span><span class="o">-</span><span class="n">user</span><span class="p">;</span> <span class="n">sid</span><span class="p">:</span><span class="mi">1000201</span><span class="p">;</span> <span class="n">rev</span><span class="p">:</span><span class="mi">1</span><span class="p">;)</span>
</pre></div>
</div>
<p>Diese Regel erkennt einen SSH Brute Force angriff.</p>
<p><strong>DoS</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alert</span> <span class="n">tcp</span> <span class="nb">any</span> <span class="nb">any</span> <span class="o">-&gt;</span> <span class="mf">192.168</span><span class="o">.</span><span class="mf">0.10</span> <span class="mi">22</span> <span class="p">(</span><span class="n">msg</span><span class="p">:</span><span class="s2">&quot;SSH DOS against 192.168.0.10&quot;</span><span class="p">;</span> \
<span class="n">detection_filter</span><span class="p">:</span><span class="n">track</span> <span class="n">by_src</span><span class="p">,</span> <span class="n">count</span> <span class="mi">50</span><span class="p">,</span> <span class="n">seconds</span> <span class="mi">1</span><span class="p">;</span> <span class="n">classtype</span><span class="p">:</span> <span class="n">denial</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">service</span><span class="p">;</span> <span class="n">sid</span><span class="p">:</span><span class="mi">1000301</span><span class="p">;</span> <span class="n">rev</span><span class="p">:</span><span class="mi">1</span><span class="p">;)</span>
</pre></div>
</div>
<p>Diese Regeln erkennt einen SSH Denial-of-Service angriff.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alert</span> <span class="n">tcp</span> <span class="nb">any</span> <span class="nb">any</span> <span class="o">-&gt;</span> <span class="mf">192.168</span><span class="o">.</span><span class="mf">0.10</span> <span class="mi">22</span> <span class="p">(</span><span class="n">msg</span><span class="p">:</span><span class="s2">&quot;SSH DDOS against 192.168.0.10&quot;</span><span class="p">;</span> \
<span class="n">detection_filter</span><span class="p">:</span><span class="n">track</span> <span class="n">by_dst</span><span class="p">,</span> <span class="n">count</span> <span class="mi">500</span><span class="p">,</span> <span class="n">seconds</span> <span class="mi">1</span><span class="p">;</span> <span class="n">classtype</span><span class="p">:</span> <span class="n">denial</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">service</span><span class="p">;</span> <span class="n">sid</span><span class="p">:</span><span class="mi">1000306</span><span class="p">;</span> <span class="n">rev</span><span class="p">:</span><span class="mi">1</span><span class="p">;)</span>
</pre></div>
</div>
<p>Gleich wie oben, nur ist diese Regel für das Erkennen eines Distributed-Denial-of-Service Angriffs zuständig.</p>
</div>
</div>
<div class="section" id="fazit-und-ausblick">
<h2><span class="section-number">3.10. </span>Fazit und Ausblick<a class="headerlink" href="#fazit-und-ausblick" title="Link zu dieser Überschrift">¶</a></h2>
<div class="section" id="fazit">
<h3><span class="section-number">3.10.1. </span>Fazit<a class="headerlink" href="#fazit" title="Link zu dieser Überschrift">¶</a></h3>
<p>Durch die Implementierung eines Intrusion Detection Systems können wir jetzt den Netzwerkverkehr
überwachen sowie Angriffe und unberechtigte Zugriffe erkennen. Mit dem entwickeln von eigenen SSH, HTML, MODBUS
und ICMP Regeln, konnten wir Snort an das LICSTER-Testbed so anpassen, dass erkannt wird welches Gerät vom
LICSTER-Testbed angegriffen wird. So kann man direkt sehen welches Gerät unter Angriff steht und man kann direkt
dagegen vorgehen. Auch werden die Logs mittels einem Cronjob im Minutentakt mit SCP an die Webapplikation
versendet.</p>
</div>
<div class="section" id="ausblick">
<h3><span class="section-number">3.10.2. </span>Ausblick<a class="headerlink" href="#ausblick" title="Link zu dieser Überschrift">¶</a></h3>
<p>Nachdem jetzt das LICSTER-Testbed mit Snort überwacht wird, kann man zusätzlich noch weitere an das
LICSTER-Testbed angepasste Regeln entwickeln, um mehr LICSTER spezifische Angriffe zu erkennen. Ergänzend
kann man ein Intrusion Prevention System (IPS) implementieren. Ein IPS kann neben den Funktionen eines IDS,
wie das erkennen eines Angriffs auch aktiv Angriffe verhindern, indem es die jeweiligen Pakete im Netzwerkverkehr
dropped.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="seccom.html" class="btn btn-neutral float-right" title="4. Secure Communication" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="kommunikation.html" class="btn btn-neutral float-left" title="2. Workflow" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Fabian Klemm, Eric Hoffmann, Raphael Hausmanninger, Michael Janzer, Muhammet Bilbey, Athanasios Luludis, Janis Schickram

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>