%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,ngerman]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage[,numfigreset=2,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{sphinxbericht Documentation}
\date{10.07.2020}
\release{2020}
\author{Team 6}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\begin{DUlineblock}{0em}
\item[] Hochschule Augsburg
\item[] Fakultät für Informatik
\item[] Projektarbeit
\item[] Sommersemester 2020
\end{DUlineblock}


\chapter{\sphinxstylestrong{Team}}
\label{\detokenize{index:team}}
\begin{DUlineblock}{0em}
\item[] Fabian Klemm, \textless{}\textgreater{}
\item[] Eric Hoffmann, \textless{}\sphinxhref{mailto:Eric.Hoffmann1@hs-augsburg.de}{Eric.Hoffmann1@hs\sphinxhyphen{}augsburg.de}\textgreater{}
\item[] Raphael Hausmanninger, \textless{}\sphinxhref{mailto:Raphael.Hausmanninger@hs-augsburg.de}{Raphael.Hausmanninger@hs\sphinxhyphen{}augsburg.de}\textgreater{}
\item[] Michael Janzer, \textless{}\textgreater{}
\item[] Muhammet Bilbey \textless{}\textgreater{}
\item[] Athanasios Luludis \textless{}\textgreater{}
\item[] Janis Schickram, \textless{}\sphinxhref{mailto:Janis.Schickram@hs-augsburg.de}{Janis.Schickram@hs\sphinxhyphen{}augsburg.de}\textgreater{}
\end{DUlineblock}

Inhalt:


\section{Einleitung}
\label{\detokenize{einleitung:einleitung}}\label{\detokenize{einleitung::doc}}
Industriekontrollsysteme sind heutzutage sehr weit verbreitet und elementar wichtig für die Wirtschaft sowie die Infrastruktur. Durch die Digitalisierung werden diese immer enger mit einander verbunden um einen Fernzugriff bzw. eine Überwachung zu ermöglichen. Da es jedoch mehr Schwachstellen gibt, wächst das Risiko eines Angriffes stark. Ziel dieses Projektes ist es ein günstiges Testbed zu schaffen, um die Sicherheit von Industriekontrollsystemen zu erhöhen.

Am Afang des Projektes haben wir eine klare Gruppeneinteilung zu den jeweiligen Unterprojekten (IDS, SecCom und Web\sphinxhyphen{}Applikation) gemacht. Dies hatte zur Folge dass auch unter den Gruppen viel kommuniziert werden musste.


\section{Workflow}
\label{\detokenize{kommunikation:workflow}}\label{\detokenize{kommunikation::doc}}
Jedes Projekt sollte damit es erfolgreich wird einen einheitlichen Workflow besitzen.
Dieser dient zur Planung, Nutzung der Ressourcen und damit das Ziel vom Projekt nicht
verfehlt wird. Zur Kommunikation im Team nützten wir verschiedene Technologien und
Vorgehensweisen, um eine möglichst gute kooperative Arbeitsweise zu ermöglichen.
Diese Strategien werden im Folgenden genauer erklärt.


\subsection{Jitsi}
\label{\detokenize{kommunikation:jitsi}}
Um die Kommunikation mit dem Professor herzustellen wurde das Tool jitsi benützt.
Der Vorteil dabei liegt darin das man sich keinen Account erstellen muss.
Somit wurde es ermöglicht das jeder leicht an den Meetings teilnehmen konnte.
Das Meeting mit dem Professor war standartmäßig immer am Donnerstag um 17:30.


\subsection{Discord}
\label{\detokenize{kommunikation:discord}}
Zur Besprechung und falls es Themen gibt, die mit dem Team besprochen werden mussten
wurde Discord benützt. Dabei wurden mehrere Text Kanäle und sprach Kanäle erstellt,
die man benutzten, kann. Bei den Text Kanälen wurde drauf geachtet das jeder punkt
einen eigenen Kanal hat. Dies haben wir getan damit eine gute Übersicht gewährleistet
wird und man somit auch bei einem späteren Zeitpunkt die Informationen leicht nachschauen
kann die man braucht.

\noindent\sphinxincludegraphics{{Discord}.png}


\subsection{Jira}
\label{\detokenize{kommunikation:jira}}
Für die zentrale Verwaltung der aufgaben wurde das Tool jira benützt. Dabei wurde mit
dem Scrum Prinzip gearbeitet. In Scrum arbeitet man mit sogenannten Sprints. Diese
bestimmen einen Zeitraum, bei uns 1\sphinxhyphen{}2 Wochen, in der bestimmte Aufgaben erledigt
werden müssen. Die Arbeitsweise funktionierte so dass man sich am Anfang einer jeden
Woche drauf geeinigt hat welche aufgaben erledigt werden müssen diese wurden dann den
jeweiligen Personen zugewiesen. Ideen oder aufgaben die für diese Woche noch nicht zu
bearbeiten sind oder noch nicht möglich sind zu bearbeiten wurden ins Backlog gesetzt.
Die aufgaben könne dabei drei zustände einnehmen: Aufgabe, wird ausgeführt und fertig.

\noindent\sphinxincludegraphics{{Jira}.png}


\section{Intrusion Detection System}
\label{\detokenize{ids:intrusion-detection-system}}\label{\detokenize{ids::doc}}
In unserer heutigen Zeit nehmen Angriffe auf industriele Systeme stetig weiter zu.
Immer wieder werden neue arten gefunden wie ein System angegriffen werden kann.
Dementsprechend gibt es auch schon sehr viele verschieden Tools die dafür da sind um
zu erkennenden wenn ein Angriff oder ein exploit auf einem System ausgeführt wird und
diesen dann auch dementsprechend zu stoppen:  Software wie Firewalls verhindern dass
nicht autorisierter Datenverkehr in das Netzwerk gelangt, Spam\sphinxhyphen{}Filter um unerwünschte
E\sphinxhyphen{}Mail\sphinxhyphen{}Nachrichten zu verhindern und Antiware\sphinxhyphen{}Tools zum Schutz von Endpunkten vor Malware.
All diese Tools werden in so gut wie jedem Unternehmen eingesetzt egal welche Branche
oder wie groß es ist. Ein weiteres wertvolles Sicherheitstool was ebenfalls eingesetzt
wird ist ein Netzwerk\sphinxhyphen{}IDS (Intrusion Detection\sphinxhyphen{}System). Um dieses geht es auch in unserem
Teil Projekt, bei dem wir ein solches System in dem Testbed Licster implementiert haben.


\subsection{Unser Team}
\label{\detokenize{ids:unser-team}}
Unser Team für das Teilprojekt „Intrusion Detection System“ (IDS) besteht aus drei Leuten, die auch schon in ihrem Studium einen starken Fokus auf IT\sphinxhyphen{}Sicherheit gelegt haben. Wir haben zusammen mehrerer Kurse in Richtung IT\sphinxhyphen{}Sicherheit besucht und teilen uns die Faszination Systeme sicherer machen zu wollen. Deswegen wurde schnell klar, dass unser Team einen großen Wert auf den Sicherheitsaspekt von LICSTER legen wird.
Die Sicherheitslage von Industriesystemen auf der ganzen Welt wird immer kritischer. Bei Angriffen auf diese Systeme können in kürzester Zeit große wirtschaftliche Schäden erzielt werden.

\noindent\sphinxincludegraphics{{cyberattacken}.png}

Deswegen haben wir uns zur Aufgabe gemacht, LICSTER eine weitere Sicherheitsschicht hinzuzufügen. Schnell wurde klar, dass ein IDS eine schnelle und aufwandseffiziente Lösung für unsere Problemstellung ist. Ein IDS kann in ein bestehendes System eingebaut werden, ohne dass direkte Änderungen am System gemacht werden müssen. Dies war uns besonders wichtig, da LICSTER bereits vor unserem Projekt schon fertiggestellt war und wir keine konzeptuelle Änderung mehr nachträglich realisieren wollten. Ein bestehendes IDS zu Nutzen hat es uns ermöglicht den zeitlichen Rahmen des Projekts einzuhalten und nützliche Fähigkeiten für unser weiteres Studium zu erlernen.


\subsection{Einrichtung Pi}
\label{\detokenize{ids:einrichtung-pi}}
Für die Realisierung des IDS wurde sich für ein Raspberry Pi 4 entschieden. Mit 4 GB RAM in der ausgewälten Konfiguration ist das Pi geeignet Snort als IDS laufen zu lassen. Als Betriebssystem wird das Raspberry Pi OS (früher Raspbian genannt) genutzt, welches von der offiziellen Seite bezogen wurde (\sphinxurl{https://www.raspberrypi.org/downloads/}). Dies wurde mit einem Image\sphinxhyphen{}Tool auf eine SD\sphinxhyphen{}Karte gespielt und über SSH wurden dann die restlichen Einrichtungen vorgenommen. Nachdem alles eingerichtet war, konnte das Pi in das LICSTER Netzwerk eingesetzt werden. Das Pi wurde an den Mirrorport des Switchs angeschlossen, damit der gesamte Traffic des LICSTERs am Pi empfangen werden kann. Um durch den Dauerbetrieb entstehende Abwärme entgegenzuwirken wurde eine Hülle mit Lüftern für das Pi angeschafft. Im Home\sphinxhyphen{}Verzeichnis wurde das Git aus GitLab gecloned. Dieses Repository enthält die Configs und Rules für Snort, sowie weitere Skripte für das IDS.

\noindent\sphinxincludegraphics{{Rapsberry_IDS_Showcase}.jpg}


\subsection{Einrichtung VM}
\label{\detokenize{ids:einrichtung-vm}}
Aus Kostengründen konnte nicht für jedes der drei Mitglieder ein Raspberry Pi gekauft werden. Dieses Problem wurde mit Virtuellen Maschinen gelöst. Virtuelle Maschinen emulieren bestimmte Hardware als Software auf einem Hostsystem. Als Virtualisierungssoftware wurde VirtualBox verwendet welches ein Image des Raspberry Pi Desktops nutzte. Somit konnte jedes Mitglied seine eigenes Raspberry Pi simulieren und jede Aufgabe konnte von Jedem erledigt werden. Bei der Einrichtung des Betriebssystems musste auf die bautechnischen Beschränkungen des Raspberry Pi 4 geachtet werden. Somit musste in der VM der Hauptspeicher auf 4 GB RAM beschränkt und der Festplattenspeicher musste auf die 64 GB der eingebauten SD\sphinxhyphen{}Karte begrenzt werden.


\subsection{Was ist ein IDS}
\label{\detokenize{ids:was-ist-ein-ids}}
Doch was genau ist nun ein Intrusion Detection system. Eine gute Definition für ein ids
lauten folgend. „Ein IDS (Intrusion Detection System) ist ein Gerät oder eine Anwendung,
mit der der gesamte Netzwerkverkehr überprüft und der Benutzer oder Administrator
benachrichtigt wird, wenn nicht autorisierte Versuche oder Zugriffe stattgefunden haben.“
Im Gegensatz zu einer Firewall welche meist eher als Gatekeeper fungiert also nur den
Netzwerkverkehr überwacht und bestimmt ob er ins Netzwerk darf. Konzentriert sich Ids
System auf den traffic, der im internen Netzwerk abläuft. Dabei wird anhand von
verschieden rule sets geschaut ob ein traffic verdächtig ist bzw. er sich ungewöhnlich
verhält bspw. Modbus mehr traffic in der Sekunde als eigentlich der Standard für das
System ist. Durch diese Weise kann ein ids Angriffe erkennen welche an der Firewall
vorbei kommen oder aus dem eigenem Netzwerk stammen.


\subsection{Wieso man es braucht}
\label{\detokenize{ids:wieso-man-es-braucht}}
Keine Firewall ist Fehler frei und kein Netzwerk ist undurchdringlich. Angreifer
entwickeln ständig neue Exploits und Angriffstechniken, um auf ein System zu kommen.
Was von fielen Angreifern zusätzlich gerne genutzt wird ist Social Engineering oder
andere arten von Malware. Über diese Methoden gelangen sie meist an Benutzeranmeldeinformationen
und dadurch haben sie nun einen berechtigten zugriff auf das Netzwerk ohne das die
Firewall dies als böswilligen angriff sieht. Ein Network Intrusion Detection System kann
dagegen immer noch sehe was die Person auf dem System macht und falls dabei nun versucht
wird das irgendwelche angriffe ausgeführt werden diese auch erkennen und den System
Administrator zu benachrichtigen das dort was im System nicht stimmt.

Der Haupt Zweck eines ids systems besteht somit darin das It\sphinxhyphen{}Personal zu benachrichtigen
falls es einen Angriff oder andere Arten von Bad traffic gefunden hat. Die Kunst für das
Personal besteht nun darin zu schauen welche nachrichtig stimmen und welche ein false
positiv sind.


\subsection{Arten von IDS}
\label{\detokenize{ids:arten-von-ids}}
Im Grundlegen werden zwischen zwei Arten von ids Systemen unterschieden nämlich der signature\sphinxhyphen{}based detection
und der anomaly\sphinxhyphen{}based detection.


\subsubsection{Signature\sphinxhyphen{}based detection}
\label{\detokenize{ids:signature-based-detection}}
Bei dieser Methode werden feste Muster verwendet, um den traffic zu kontrollieren.
Diese Muster beschreiben verdächtige Sammlung von Abfolgen von Aktivitäten oder
Operationen, die möglicherweise schädlich sein können. Diese werden dann meist in einer
Datenbank gespeichert. Es werden somit genau definierte Angriffsmuster verwendet,
die die Schwachstelen im System ausnutzten. Die Zeit, die somit gebraucht wird, um den
traffic zu vergleichen ist minimal. Der Hauptvorteil besteht somit darin das Muster oder
Signaturen das Netzwerkverhalten leicht verstehen zu können. Es ist somit effizienter
Angriffe zu verarbeiten die schon bekannt sind.

Die Hauptbeschränkung dieses Systems ist dadurch das Reagieren und Erkennen von Angriffen,
die nicht in der Datenbank gespeichert sind. Somit kann dieses System leicht getäuscht
werden das es nur mit einem bestimmten Satz von ausdrücken oder mit Zeichenfolgenübereinstimmung
arbeiten. Desweitern tuen sich solches System sehr schwer mit Angriffen bei denen
Menschen aktiv etwas tun.


\subsubsection{Anomaly\sphinxhyphen{}based detection}
\label{\detokenize{ids:anomaly-based-detection}}
Bei diesem System ist das Netzwerkverhalten der Haupt Parameter. Deshalb wird vorerst ein
Model erstellt, welches zeigt wie der normale traffic im Netzwerk aussehen soll.
Dieser kann entweder vorbestimmt werden oder durch vom Netzwerkadministrator festgelegte
Spezifikationen oder Bedingungen mit machine learning gelernt werden. Wenn das
Netzwerkverhalten innerhalb des Models liegt passt alles falls nicht wir eine Wahrung
vom Anomaly detection system ausgelöst.

Das Definieren der Regelsätze ist einer der Hauptnachteile des Anomaly detection systems.
Die Effizienz des Systems hängt von der effektiven Implementierung und dem Testen von
Regelsätzen für alle Protokolle ab. Darüber hinaus wirken sich verschiedene Protokolle
verschieden stark auf das System aus. Des Weiteren hat das System Probleme dabei wen das
böswillige Verhalten unter das akzeptierende Verhalten fällt.


\subsection{Wireshark}
\label{\detokenize{ids:wireshark}}
Um einen Überblick über die Pakete, die im LICSTER Netzwerk unterwegs sind, zu
bekommen, haben wir, mit Wireshark, den Netzwerkverkehr aufgezeichnet.

Als erstes haben wir pcaps während dem Einschalten, Betrieb und Abschalten von dem Testbed, mithilfe des Mirror Ports erstellt,
um zu sehen was während einem Regulären betrieb auf dem Netzwerk passiert.

\noindent\sphinxincludegraphics{{wireshark_normal}.png}

Als nächstes haben wir pcaps von Angriffen, die wir Durchgeführt haben, aufgezeichnet, um Regeln für unser Intrusion\sphinxhyphen{}Detection\sphinxhyphen{}System entwickeln zu können.

\noindent\sphinxincludegraphics{{wireshark_flood}.png}


\subsubsection{Durchgeführte Angriffe}
\label{\detokenize{ids:durchgefuhrte-angriffe}}
Die Skripte für die Angriffe sind im Offiziellen Github Repository zu finden (\sphinxurl{https://github.com/hsainnos/LICSTER/tree/master/attacks}).


\paragraph{Flooding}
\label{\detokenize{ids:flooding}}
Flooding ist eine einfache und beliebte Art eines Denial\sphinxhyphen{}of\sphinxhyphen{}Service Angriffs.
Für den Angriff haben wir hping3 benutzt. Ein Einfaches CLI\sphinxhyphen{}tool um Pakete zu versenden.

Hier wird eins der beiden RemoteIO’s vom LICSTER Testbed geflutet.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} sudo hping3 \PYGZhy{}\PYGZhy{}flood 192.168.0.51
\end{sphinxVerbatim}


\paragraph{Angriff auf das Fließband}
\label{\detokenize{ids:angriff-auf-das-flieszband}}
Hier haben wir mit einem kleinen Python\sphinxhyphen{}Skript das Fließband vom LICSTER Testbed angegriffen und zum stoppen gebracht.
Ausgeführt wird er mit:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} sudo ./conveyer\PYGZus{}belt.py
\end{sphinxVerbatim}


\paragraph{Angriff auf die manuelle Kontrolle}
\label{\detokenize{ids:angriff-auf-die-manuelle-kontrolle}}
Hier wird, mit einem Python\sphinxhyphen{}Skript, die manuelle Kontrolle vom LICSTER Testbed übernommen.
Ausgeführt wird er mit:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} python3 \PYGZhy{}i client.py
\PYGZgt{}\PYGZgt{}\PYGZgt{}
\end{sphinxVerbatim}

Anschließend kann man dann Befehle senden um das Testbed zu steuern.


\subsection{Snort}
\label{\detokenize{ids:snort}}

\subsubsection{Wieso Snort?}
\label{\detokenize{ids:wieso-snort}}
Es wurde sich für Snort entschieden, da es schon seit längerem auf dem Markt verfügbar ist. Dank dieser Zeit ist Snort sehr ausgereift und auch weit verbreitet. Es ist kostenlos und durch seine große Community ist es leicht bei Problemen Unterstützung zu bekommen. Ein weiterer Punkt, warum sich für Snort entschieden wurde, ist, dass bereits einige Gruppenmitglieder sich ein wenig mit den Regeln auskannten. Die Syntax der Regeln ist leicht zu verstehen, bieten aber dennoch die nötige Komplexität, um aussagekräftige Meldungen zu bekommen.


\subsubsection{Snort Einrichtung}
\label{\detokenize{ids:snort-einrichtung}}
Als Erstes hat jedes Gruppenmitglied Snort bei seiner eigenen VM eingerichtet. So konnten schon die ersten Erfahrungen mit den Regeln und der Funktion von Snort gesammelt werden. Dann wurde abgewogen, welche Snort Version am geeignetsten für das Vorhaben ist. Zur Auswahl standen v2 und v3. Die neuere Version v3 besitzt neue Funktionen, aber dies kommt auch mit Performanceeinbußen einher. Da das Raspberry Pi 4 nur begrenzte Rechenleistung und Hauptspeicher besitzt, wurde sich für die ausgereiftere v2 entschieden. Snort wurde über apt install snort bezogen und war dann auch bereit für den Einsatz. Um die gleichen Konfigurationen und Regeln zu haben, wurde ein GitLab Repository eingerichtet welches alle Konfigurationsdateien und Regeln beinhaltet. Somit musste, um Snort zu starten, nur noch der Pfad zu der Konfiguration angegeben werden. Diese Konfigurationsdatei beinhaltete wiederrum die relativen Pfade zu den Regeln im Repository. Nach der Einrichtung sieht der Befehl zum Starten von Snort so aus: sudo snort \sphinxhyphen{}c /path/to/snort.conf


\subsubsection{Snort Regeln}
\label{\detokenize{ids:snort-regeln}}
Damit Snort Angriffe/Abnormalitäten erkennen kann, müssen Regeln vorhanden sein, wonach Snort sich richten kann. Darauf Achten sollte man, dass man nicht zu viele Regeln implementiert, denn so kann es passieren, das Snort zu viele Alarme wirft, von denen viele  falsch sind und der echte Alarm untergeht (Man sieht den Angriff vor lauter „Angriffe“ nicht mehr). Hat man aber zu wenige Regel implementiert, kann es passieren, dass mögliche Angriffe nicht erkannt werden. Es müssen also so wenig Regeln wie möglich, aber so viele wie nötig implementiert werden um Fehlalarme zu vermeiden und dennoch echte Angriffe erkennen zu können.


\paragraph{Regel schreiben}
\label{\detokenize{ids:regel-schreiben}}
Damit man Regeln schreiben kann muss man erst verstehen wie eine Regel
aufgebaut ist. Hier Hilft die offizielle Anleitung
(\sphinxurl{http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node27.html}).

Hier in Kurzfassung:

Eine Regel besteht aus drei Teilen:
\begin{itemize}
\item {} 
Aktion

\item {} 
Kopf

\item {} 
Regeloptionen

\end{itemize}


\paragraph{Aktion}
\label{\detokenize{ids:aktion}}
Hier wird angegeben was Snort tun soll, wenn es ein Paket findet, das den
Regel Kriterien entspricht. Es gibt 3 verfügbare Standardaktionen in Snort,
alert, log und pass. Wenn Snort im inline\sphinxhyphen{}modus ausgeführt wird, stehen drop,
reject und sdrop zur verfügung.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\textquotesingle{}alert\textquotesingle{}}} erzeugt einen Alarm mit der gewählten Alarm Methode und protokolliert dann das Paket

\item {} 
\sphinxcode{\sphinxupquote{\textquotesingle{}log\textquotesingle{}}} das Paket protokollieren

\item {} 
\sphinxcode{\sphinxupquote{\textquotesingle{}pass\textquotesingle{}}} das Paket ignorieren

\item {} 
\sphinxcode{\sphinxupquote{\textquotesingle{}drop\textquotesingle{}}} das Paket blockieren und protokollieren

\item {} 
\sphinxcode{\sphinxupquote{\textquotesingle{}reject\textquotesingle{}}} das Paket blockieren, protokollieren und senden eines TCP\sphinxhyphen{}Reset, wenn das Protokoll TCP ist, oder eine ICMP\sphinxhyphen{}Port\sphinxhyphen{}Unerreichbarkeit Meldung, wenn das Protokoll UDP ist.

\item {} 
\sphinxcode{\sphinxupquote{\textquotesingle{}sdrop\textquotesingle{}}} das Paket blockieren, aber nicht protokollieren

\end{itemize}


\paragraph{Kopf}
\label{\detokenize{ids:kopf}}
Dieses Feld steht für das Protokoll, die IP Adresse, die Ports und die
Richtungsanweisung.

\sphinxstylestrong{Protokolle}

Es gibt vier Protokolle, die Snort auf verdächtiges Verhalten analysiert: TCP,
UDP, ICMP und IP.

\sphinxstylestrong{IP Adressen und Ports}

Der nächste Teil des Regelkopfes befasst sich mit der IP\sphinxhyphen{}Adresse und den Port
für eine bestimmte Regel. Man kann das Heimnetzwerk in der Konfigurationsdatei
von Snort festlegen. Das Schlüsselwort any kann zur Definition einer beliebigen
Adresse verwendet werden.


\paragraph{Regeloptionen}
\label{\detokenize{ids:regeloptionen}}
Alle Regeloptionen werden durch das Semikolon (;) voneinander getrennt.
Es gibt vier Kategorien von Regeloptionen:
\begin{itemize}
\item {} \begin{description}
\item[{general}] \leavevmode
enthält extra Informationen über die Regel, haben aber keine auswirkung während der Erkennung

\end{description}

\item {} \begin{description}
\item[{payload}] \leavevmode
diese Optionen schauen in den Packet\sphinxhyphen{}Payload rein

\end{description}

\item {} \begin{description}
\item[{non\sphinxhyphen{}payload}] \leavevmode
diese Optionen schauen für nicht payload Daten

\end{description}

\item {} \begin{description}
\item[{post\sphinxhyphen{}detection}] \leavevmode
diese Optionen sind Regelspezifische trigger, die ausgeführt werden, nachdem eine Regel ausgelöst wird

\end{description}

\end{itemize}

\noindent\sphinxincludegraphics{{rules}.png}

Für genauere Regeloptionen schaut man hier am besten nach:
\sphinxurl{http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node32.html}


\subsection{Unsere Snort Regeln}
\label{\detokenize{ids:unsere-snort-regeln}}

\subsubsection{HTTP Regeln}
\label{\detokenize{ids:http-regeln}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
alert tcp !\PYGZdl{}HOME\PYGZus{}NET any \PYGZhy{}\PYGZgt{} 192.168.0.10 \PYGZdl{}HTTP\PYGZus{}PORTS (msg:\PYGZdq{}HTTP Get from EXTERNAL to 192.168.0.10\PYGZdq{}; \PYGZbs{}
classtype: bad\PYGZhy{}unknown; content: \PYGZdq{}HTTP\PYGZdq{}; sid 1002000; rev: 1;)
\end{sphinxVerbatim}

Diese Regel ist dafür da, falls von einem Außenstehenden Netzwerk ein HTTP GET request empfangen worden ist.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
alert tcp !192.168.20 any \PYGZhy{}\PYGZgt{} 192.168.30 \PYGZdl{}HTTP\PYGZus{}PORTS (msg:\PYGZdq{}HTTP Get not from 192.168.0.20 to 192.168.0.30\PYGZdq{}; \PYGZbs{}
classtype: bad\PYGZhy{}unknown; content: \PYGZdq{}HTTP\PYGZdq{}; sid 1002005; rev: 1;)
\end{sphinxVerbatim}

Hier ähnlich wie bei der vorherigen Regel, nur wird hier der Alarm geworfen, falls das GET request vom Heimnetz, aber nicht vom HMI, kommt.


\subsubsection{ICMP Regel}
\label{\detokenize{ids:icmp-regel}}
\sphinxstylestrong{Portscan}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{alert} \PYG{n}{icmp} \PYG{n+nb}{any} \PYG{n+nb}{any} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{0.10} \PYG{n+nb}{any} \PYG{p}{(}\PYG{n}{msg}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ping nmap Portscan 192.168.0.10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;} \PYGZbs{}
\PYG{n}{dsize}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{itype}\PYG{p}{:}\PYG{l+m+mi}{8}\PYG{p}{;} \PYG{n}{classtype}\PYG{p}{:} \PYG{n}{network}\PYG{o}{\PYGZhy{}}\PYG{n}{scan}\PYG{p}{;} \PYG{n}{sid}\PYG{p}{:}\PYG{l+m+mi}{1003000}\PYG{p}{;} \PYG{n}{rev}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{)}
\end{sphinxVerbatim}

ICMP\sphinxhyphen{}Fehlermeldungen (Protocol/Port Unreachable) können verwendet werden, um die offenen Ports zu einer IP\sphinxhyphen{}Adresse herauszufinden.
Da die Paketgröße 0 ist wird hier \sphinxcode{\sphinxupquote{\textquotesingle{}dsize\textquotesingle{}}} auf 0 gesetzt und der \sphinxcode{\sphinxupquote{\textquotesingle{}itype\textquotesingle{}}} auf 8, da der Typ 8 für Echo Request steht.

\sphinxstylestrong{DoS}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{alert} \PYG{n}{icmp} \PYG{n+nb}{any} \PYG{n+nb}{any} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{0.10} \PYG{n+nb}{any} \PYG{p}{(}\PYG{n}{msg}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ping flood detected 192.168.0.10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;} \PYGZbs{}
\PYG{n}{itype}\PYG{p}{:}\PYG{l+m+mi}{8}\PYG{p}{;} \PYG{n}{count} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{seconds} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{classtype}\PYG{p}{:} \PYG{n}{denial}\PYG{o}{\PYGZhy{}}\PYG{n}{of}\PYG{o}{\PYGZhy{}}\PYG{n}{service}\PYG{p}{;} \PYG{n}{sid}\PYG{p}{:}\PYG{l+m+mi}{1003010}\PYG{p}{;} \PYG{n}{rev}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{)}
\end{sphinxVerbatim}

Standard DoS Ping flood.

\sphinxstylestrong{DoS Teardrop}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{alert} \PYG{n}{icmp} \PYG{n+nb}{any} \PYG{n+nb}{any} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{0.10} \PYG{n+nb}{any} \PYG{p}{(}\PYG{n}{msg}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ICMP Teardrop attack 192.168.0.10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;} \PYGZbs{}
\PYG{n}{fragbits}\PYG{p}{:}\PYG{n}{M}\PYG{p}{;} \PYG{n}{classtype}\PYG{p}{:} \PYG{n}{denial}\PYG{o}{\PYGZhy{}}\PYG{n}{of}\PYG{o}{\PYGZhy{}}\PYG{n}{service}\PYG{p}{;} \PYG{n}{sid}\PYG{p}{:}\PYG{l+m+mi}{1003020}\PYG{p}{;}\PYG{n}{rev}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{)}
\end{sphinxVerbatim}

Teardrop\sphinxhyphen{}Angriffe senden Fragmentierte Pakete die nicht wieder zusammengesetzt werden können, das zu einem DoS führen kann. Um den Angriff zu erkennen,
wird hier \sphinxcode{\sphinxupquote{\textquotesingle{}fragbits\textquotesingle{}}} auf \sphinxcode{\sphinxupquote{\textquotesingle{}M\textquotesingle{}}} für more gesetzt, was heißt dass noch mehr Pakete kommen.

\sphinxstylestrong{ICMP Router Discovery}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{alert} \PYG{n}{icmp} \PYG{n+nb}{any} \PYG{n+nb}{any} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{0.10} \PYG{n+nb}{any} \PYG{p}{(}\PYG{n}{msg}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ICMP Router Discovery 192.168.0.10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;} \PYGZbs{}
\PYG{n}{icode}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{itype}\PYG{p}{:}\PYG{l+m+mi}{9}\PYG{p}{;} \PYG{n}{classtype}\PYG{p}{:} \PYG{n}{network}\PYG{o}{\PYGZhy{}}\PYG{n}{scan}\PYG{p}{;} \PYG{n}{sid}\PYG{p}{:}\PYG{l+m+mi}{1003030}\PYG{p}{;} \PYG{n}{rev}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{)}
\end{sphinxVerbatim}

Ähnlich wie beim Portscan, nur werden hier nach Benachbarten Routern gesucht. \sphinxcode{\sphinxupquote{\textquotesingle{}itype\textquotesingle{}}} wird auf 9 gesetzt da es für Router Advertisement steht.

\sphinxstylestrong{ICMP Too large packet}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{alert} \PYG{n}{icmp} \PYG{n+nb}{any} \PYG{n+nb}{any} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{0.10} \PYG{n+nb}{any} \PYG{p}{(}\PYG{n}{msg}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Large ICMP Packet 192.168.0.10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;} \PYGZbs{}
\PYG{n}{dsize}\PYG{p}{:}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1500}\PYG{p}{;} \PYG{n}{classtype}\PYG{p}{:} \PYG{n}{denial}\PYG{o}{\PYGZhy{}}\PYG{n}{of}\PYG{o}{\PYGZhy{}}\PYG{n}{service}\PYG{p}{;} \PYG{n}{sid}\PYG{p}{:}\PYG{l+m+mi}{1003040}\PYG{p}{;} \PYG{n}{rev}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{)}
\end{sphinxVerbatim}

Diese Regel ist dafür da, falls zu große ICMP Pakete gesendet werden. \sphinxcode{\sphinxupquote{\textquotesingle{}dsize\textquotesingle{}}} ist für die Paketgröße und wurde hier auf größer 1500 gesetzt.


\subsubsection{Modbus Regel}
\label{\detokenize{ids:modbus-regel}}
\sphinxstylestrong{DoS}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{alert} \PYG{n}{tcp} \PYG{n+nb}{any} \PYG{n+nb}{any} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{0.51} \PYG{l+m+mi}{502} \PYG{p}{(}\PYG{n}{msg}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Modbus threshold violation 51}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;} \PYG{n}{threshold}\PYG{p}{:} \PYGZbs{}
\PYG{n+nb}{type} \PYG{n}{both}\PYG{p}{,} \PYG{n}{track} \PYG{n}{by\PYGZus{}dst}\PYG{p}{,} \PYG{n}{count} \PYG{l+m+mi}{60}\PYG{p}{,} \PYG{n}{seconds} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{classtype}\PYG{p}{:} \PYG{n}{successful}\PYG{o}{\PYGZhy{}}\PYG{n}{dos}\PYG{p}{;} \PYG{n}{sid}\PYG{p}{:}\PYG{l+m+mi}{1001004}\PYG{p}{;}\PYG{p}{)}
\end{sphinxVerbatim}

Diese Regel erkennt einen Denial\sphinxhyphen{}of\sphinxhyphen{}Service Angriff über das Modbus.


\subsubsection{SSH Regel}
\label{\detokenize{ids:ssh-regel}}
\sphinxstylestrong{Strange Traffic}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
alert tcp !\PYGZdl{}HOME\PYGZus{}NET any \PYGZhy{}\PYGZgt{} 192.168.0.10 22 (msg:\PYGZdq{}SSH Request from EXTERNAL NET to 192.168.0.10\PYGZdq{}; \PYGZbs{}
content:\PYGZdq{}SSH\PYGZdq{}; nocase; offset:0; depth:4; classtype: attempted\PYGZhy{}user; sid:1000101; rev:1;)
\end{sphinxVerbatim}

Diese Regel erkennt einen SSH Zugriffs versuch aus einem externen Netz.

\sphinxstylestrong{Brute Force}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{alert} \PYG{n}{tcp} \PYG{n+nb}{any} \PYG{n+nb}{any} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n+nb}{any} \PYG{l+m+mi}{22} \PYG{p}{(}\PYG{n}{msg}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SSH Brute Force Attempt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;} \PYG{n}{flow}\PYG{p}{:}\PYG{n}{established}\PYG{p}{,} \PYG{n}{to\PYGZus{}server}\PYG{p}{;} \PYG{n}{content}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SSH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;} \PYGZbs{}
\PYG{n}{nocase}\PYG{p}{;} \PYG{n}{offset}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{depth}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{;} \PYG{n}{detection\PYGZus{}filter}\PYG{p}{:}\PYG{n}{track} \PYG{n}{by\PYGZus{}src}\PYG{p}{,} \PYG{n}{count} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{seconds} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{classtype}\PYG{p}{:} \PYG{n}{attempted}\PYG{o}{\PYGZhy{}}\PYG{n}{user}\PYG{p}{;} \PYG{n}{sid}\PYG{p}{:}\PYG{l+m+mi}{1000201}\PYG{p}{;} \PYG{n}{rev}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{)}
\end{sphinxVerbatim}

Diese Regel erkennt einen SSH Brute Force angriff.

\sphinxstylestrong{DoS}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{alert} \PYG{n}{tcp} \PYG{n+nb}{any} \PYG{n+nb}{any} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{0.10} \PYG{l+m+mi}{22} \PYG{p}{(}\PYG{n}{msg}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SSH DOS against 192.168.0.10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;} \PYGZbs{}
\PYG{n}{detection\PYGZus{}filter}\PYG{p}{:}\PYG{n}{track} \PYG{n}{by\PYGZus{}src}\PYG{p}{,} \PYG{n}{count} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{seconds} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{classtype}\PYG{p}{:} \PYG{n}{denial}\PYG{o}{\PYGZhy{}}\PYG{n}{of}\PYG{o}{\PYGZhy{}}\PYG{n}{service}\PYG{p}{;} \PYG{n}{sid}\PYG{p}{:}\PYG{l+m+mi}{1000301}\PYG{p}{;} \PYG{n}{rev}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{)}
\end{sphinxVerbatim}

Diese Regeln erkennt einen SSH Denial\sphinxhyphen{}of\sphinxhyphen{}Service angriff.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{alert} \PYG{n}{tcp} \PYG{n+nb}{any} \PYG{n+nb}{any} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{0.10} \PYG{l+m+mi}{22} \PYG{p}{(}\PYG{n}{msg}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SSH DDOS against 192.168.0.10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;} \PYGZbs{}
\PYG{n}{detection\PYGZus{}filter}\PYG{p}{:}\PYG{n}{track} \PYG{n}{by\PYGZus{}dst}\PYG{p}{,} \PYG{n}{count} \PYG{l+m+mi}{500}\PYG{p}{,} \PYG{n}{seconds} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{classtype}\PYG{p}{:} \PYG{n}{denial}\PYG{o}{\PYGZhy{}}\PYG{n}{of}\PYG{o}{\PYGZhy{}}\PYG{n}{service}\PYG{p}{;} \PYG{n}{sid}\PYG{p}{:}\PYG{l+m+mi}{1000306}\PYG{p}{;} \PYG{n}{rev}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{)}
\end{sphinxVerbatim}

Gleich wie oben, nur ist diese Regel für das Erkennen eines Distributed\sphinxhyphen{}Denial\sphinxhyphen{}of\sphinxhyphen{}Service Angriffs zuständig.


\section{Secure Communication}
\label{\detokenize{seccom:secure-communication}}\label{\detokenize{seccom::doc}}

\subsection{Einleitung}
\label{\detokenize{seccom:einleitung}}
Als die Secure Communication Gruppe haben wir uns ausschließlich mit der internen Kommunikation des LICSTERs auseinandergesetzt. Als Ziel haben wir es uns gesetzt das bereits implementierte Modbus\sphinxhyphen{}Protokoll, das in dieser Form sich als sehr unsicher bewiesen hat, zu verschlüsseln. Dabei haben wir uns dazu entschieden, das TLS\sphinxhyphen{}Protokoll einzusetzen. Dieses bietet zusätzlich zu der Verschlüsselung der Anwendungsschicht ein Handshake\sphinxhyphen{}Protokoll, das die Authentifizierung der Kommunikationspartner ermöglicht.

Veranschaulichung der ursprünglichen Kommunikation:

\sphinxhref{./assets/diagrams/No\_Secure\_Layer\_Overview.svg}{\sphinxincludegraphics{{No_Secure_Layer_Overview}.svg}}

Dies wurde realisiert, indem wir eine zusätzliche Softwareschnittstelle (Secure Layer) im PLC implementiert haben. Diese ermöglicht eine beidseitig verschlüsselte Kommunikation zwischen dem PLC und den Remote\sphinxhyphen{}IOs, indem sie eingehende Pakete von den Remote\sphinxhyphen{}IOs entschlüsselt und von dem PLC ausgehende Pakete verschlüsselt. Die interne Kommunikation im PLC zwischen dem Secure\sphinxhyphen{}Layer und dem OpenPLC findet unverschlüsselt statt.

Veranschaulichung mit Secure Layer:

\sphinxhref{./assets/diagrams/Secure\_Layer\_Overview.svg}{\sphinxincludegraphics{{Secure_Layer_Overview}.svg}}


\subsection{Secure Layer}
\label{\detokenize{seccom:secure-layer}}
Der Secure Layer (sichere Schicht) ist die Komponente die zwischen den Remote\sphinxhyphen{}IOs und OpenPLC sitz.

Detaillierte Veranschaulichung:

\sphinxhref{./assets/diagrams/Secure\_Layer\_Details.svg}{\sphinxincludegraphics{{Secure_Layer_Details}.svg}}

Der Secure Layer ist in Python3.6 geschrieben und in 2 Hauptkomponenten zu unterteilen:
\begin{itemize}
\item {} 
{\hyperref[\detokenize{seccom:bridge}]{\emph{Bridge}}}

\item {} 
{\hyperref[\detokenize{seccom:bridgemanager}]{\emph{Bridgemanager}}}

\end{itemize}


\subsubsection{Bridge}
\label{\detokenize{seccom:id1}}
Die Bridge (Brücke) besteht aus zwei TCP Verbindungen, eine TLS Verbindung zu einem Remote TCP Server, und einen lokalen TCP Server der auf eine lokale Verbindung wartet.
Um dies zu ermöglichen muss die Bridge ein wenig Modbus verstehen, da das Message\sphinxhyphen{}Framing in diesem Fall durch Informationen im Header vom Modbus Protokoll vorhanden ist.


\subsubsection{Bridgemanager}
\label{\detokenize{seccom:id2}}
Der Bridgemanager (Brückenverwalter) verwaltet die einzelnen Brücken und startet diese bei Fehlern neu.



\subsection{Remote\sphinxhyphen{}IO}
\label{\detokenize{seccom:remote-io}}



\subsubsection{Mbed TLS}
\label{\detokenize{seccom:mbed-tls}}
Um TLS auf den Remote\sphinxhyphen{}IOs zu implementieren haben wurde die Mbed TLS Bibliothek gewählt, da diese kompakt, portabel und einfach verständlich ist. Hierbei handelt es sich um ein Open\sphinxhyphen{}Source Projekt, welches auf GitHub (\sphinxurl{https://github.com/ARMmbed/mbedtls}) zu finden ist. Ein weiterer Grund der für Mbed TLS gesprochen hat ist die Tatsache, dass es innerhalb STM32CubeMX konfiguriert werden kann, und dadurch viel Zeit beim konfigurieren der Bibliothek gespart werden kann.


\subsubsection{Heap Speicher}
\label{\detokenize{seccom:heap-speicher}}
FreeRTOS verwaltet den gesamten Heap Speicher, darum schlagen Aufrufe der Standardbibliotheksfunktionen für dynamische Speicherverwaltung fehl. Das heißt jeder Aufruf an \sphinxcode{\sphinxupquote{calloc}} oder \sphinxcode{\sphinxupquote{malloc}} geben \sphinxcode{\sphinxupquote{NULL}} zurück. Jedoch benötigt Mbed TLS dynamischen Speicher. Explizit benötigt Mbed TLS \sphinxcode{\sphinxupquote{calloc}} und \sphinxcode{\sphinxupquote{free}}. Alternativ kann Mbed TLS auch mit einem statischen Block an Speicher arbeiten, jedoch wurde den dynamischen Ansatz gewählt.


Diese Implementation ist in \sphinxcode{\sphinxupquote{heap\_mem.h}} deklariert und in \sphinxcode{\sphinxupquote{heap\_mem.c}} definiert.

\sphinxcode{\sphinxupquote{heap\_mem.c}} beinhaltet Folgenden Quellcode:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}heap\PYGZus{}mem.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}cmsis\PYGZus{}os.h\PYGZdq{}}

\PYG{k}{extern} \PYG{n}{SemaphoreHandle\PYGZus{}t} \PYG{n}{alloc\PYGZus{}mutex}\PYG{p}{;}

\PYG{k+kt}{void}\PYG{o}{*} \PYG{n+nf}{rmalloc}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{size}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{ptr} \PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{;}

    \PYG{k}{if}\PYG{p}{(}\PYG{n}{size} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{while} \PYG{p}{(}\PYG{n}{xSemaphoreTake}\PYG{p}{(}\PYG{n}{alloc\PYGZus{}mutex}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{pdTRUE}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ptr} \PYG{o}{=} \PYG{n}{pvPortMalloc}\PYG{p}{(}\PYG{n}{size}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{xSemaphoreGive}\PYG{p}{(}\PYG{n}{alloc\PYGZus{}mutex}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{ptr}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void}\PYG{o}{*} \PYG{n+nf}{rcalloc}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{num}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{size}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{total} \PYG{o}{=} \PYG{n}{num} \PYG{o}{*} \PYG{n}{size}\PYG{p}{;}
    \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{ptr} \PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{;}

    \PYG{k}{if}\PYG{p}{(}\PYG{n}{total} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{while} \PYG{p}{(}\PYG{n}{xSemaphoreTake}\PYG{p}{(}\PYG{n}{alloc\PYGZus{}mutex}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{pdTRUE}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ptr} \PYG{o}{=} \PYG{n}{pvPortMalloc}\PYG{p}{(}\PYG{n}{total}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{xSemaphoreGive}\PYG{p}{(}\PYG{n}{alloc\PYGZus{}mutex}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{total}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t} \PYG{o}{*}\PYG{p}{)} \PYG{n}{ptr}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{ptr}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{rfree}\PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{ptr}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{ptr}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{while} \PYG{p}{(}\PYG{n}{xSemaphoreTake}\PYG{p}{(}\PYG{n}{alloc\PYGZus{}mutex}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{pdTRUE}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{vPortFree}\PYG{p}{(}\PYG{n}{ptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{xSemaphoreGive}\PYG{p}{(}\PYG{n}{alloc\PYGZus{}mutex}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Um diese problemlose Nebenläufigkeit in unserer eigenen Implementierung zu gewährleisten werden alle kritischen Vorgänge mit einem Mutex, bzw. Semaphore abgesichert. Der Code der das gewährleistet ist Folgender:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/*}
\PYG{c+cm}{ * Warte bis die Lock von dem Mutext genommen werden kann,}
\PYG{c+cm}{ * d.h. bis es sicher ist das kein (anderer) Thread}
\PYG{c+cm}{ * die Lock vom Mutex besitzt.}
\PYG{c+cm}{ */}
\PYG{k}{while} \PYG{p}{(}\PYG{n}{xSemaphoreTake}\PYG{p}{(}\PYG{n}{net\PYGZus{}mutex}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{pdTRUE}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cm}{/*}
\PYG{c+cm}{ * Gebe die Lock von dem Mutext ab,}
\PYG{c+cm}{ * sodass sie von einem (anderen) genommen werden kann.}
\PYG{c+cm}{ */}
\PYG{n}{xSemaphoreGive}\PYG{p}{(}\PYG{n}{net\PYGZus{}mutex}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Mbed TLS stellt die folgende Funktion bereit um eigene Implementationen der \sphinxcode{\sphinxupquote{calloc}} und \sphinxcode{\sphinxupquote{free}} Funktionen innerhalb Mbed TLS zu verwenden:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{mbedtls\PYGZus{}platform\PYGZus{}set\PYGZus{}calloc\PYGZus{}free}\PYG{p}{(} \PYG{k+kt}{void} \PYG{o}{*} \PYG{p}{(}\PYG{o}{*}\PYG{n}{calloc\PYGZus{}func}\PYG{p}{)}\PYG{p}{(} \PYG{k+kt}{size\PYGZus{}t}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{p}{)}\PYG{p}{,}
                                      \PYG{k+kt}{void} \PYG{p}{(}\PYG{o}{*}\PYG{n}{free\PYGZus{}func}\PYG{p}{)}\PYG{p}{(} \PYG{k+kt}{void} \PYG{o}{*} \PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Jedoch gilt zu beachten, dass diese Funktion nur aufgerufen werden kann wenn \sphinxcode{\sphinxupquote{MBEDTLS\_PLATFORM\_C}} und \sphinxcode{\sphinxupquote{MBEDTLS\_PLATFORM\_MEMORY}} definiert sind! Diese wurden in unserem Fall über STM32CubeMX konfiguriert.

Diese Funktion wird in \sphinxcode{\sphinxupquote{mbedtls.c}} aufgerufen:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}mbedtls.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}mbedtls/platform.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}heap\PYGZus{}mem.h\PYGZdq{}}

\PYG{k+kt}{void} \PYG{n+nf}{MX\PYGZus{}MBEDTLS\PYGZus{}Init}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{mbedtls\PYGZus{}platform\PYGZus{}set\PYGZus{}calloc\PYGZus{}free}\PYG{p}{(}\PYG{n}{rcalloc}\PYG{p}{,} \PYG{n}{rfree}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Network Stack}
\label{\detokenize{seccom:network-stack}}
Um Mbed TLS in den aktuellen LWIP Network Stack einzubringen mussten einige Anpassungen gemacht werden.

LWIP verwendet für die Adressierung der Sockets einen Index.
Dieser Index wird standardmäßig in Mbed TLS nicht richtig adressiert, was dazu führt das alle \sphinxcode{\sphinxupquote{mbedtls\_net\_context}} auf den gleichen Socket in LWIP verweisen. Diese Socketverwaltung musste somit selbst implementiert werden.
Dies wurde durch ein einfaches Array umgesetzt:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{char} \PYG{n}{socks}\PYG{p}{[}\PYG{n}{MEMP\PYGZus{}NUM\PYGZus{}NETCONN}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{MEMP\_NUM\_NETCONN}} beschreibt hierbei die Präprozessor für die maximale Anzahl an simultanen Netzwerkverbindungen.
Wenn ein Socketindex aktiv, bzw. reserviert ist wird dieser auf eine Wert der nicht \sphinxcode{\sphinxupquote{0}} ist (in diesem Fall wird er auf \sphinxcode{\sphinxupquote{1}} gesetzt).

\sphinxcode{\sphinxupquote{net\_sockets.c}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{mbedtls\PYGZus{}net\PYGZus{}init}\PYG{p}{(} \PYG{n}{mbedtls\PYGZus{}net\PYGZus{}context} \PYG{o}{*}\PYG{n}{ctx} \PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{while} \PYG{p}{(}\PYG{n}{xSemaphoreTake}\PYG{p}{(}\PYG{n}{net\PYGZus{}mutex}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{pdTRUE}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{lwip\PYGZus{}initialized}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{MX\PYGZus{}LWIP\PYGZus{}Init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{lwip\PYGZus{}initialized} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{ctx}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{fd} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{MEMP\PYGZus{}NUM\PYGZus{}NETCONN}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{socks}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{ctx}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{fd} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
            \PYG{n}{socks}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{k}{break}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{xSemaphoreGive}\PYG{p}{(}\PYG{n}{net\PYGZus{}mutex}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Beim freigeben eines \sphinxcode{\sphinxupquote{mbedtls\_net\_context}} wird dessen Socketindex auch wieder auf \sphinxcode{\sphinxupquote{0}} gesetzt, somit ist dieser wieder frei von einem anderen Socket benutzt zu werden.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{mbedtls\PYGZus{}net\PYGZus{}free}\PYG{p}{(} \PYG{n}{mbedtls\PYGZus{}net\PYGZus{}context} \PYG{o}{*}\PYG{n}{ctx} \PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(} \PYG{n}{ctx}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{fd} \PYG{o}{=}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{p}{)}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{k}{while} \PYG{p}{(}\PYG{n}{xSemaphoreTake}\PYG{p}{(}\PYG{n}{net\PYGZus{}mutex}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{pdTRUE}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{socks}\PYG{p}{[}\PYG{n}{ctx}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{fd}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{xSemaphoreGive}\PYG{p}{(}\PYG{n}{net\PYGZus{}mutex}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{shutdown}\PYG{p}{(} \PYG{n}{ctx}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{fd}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{p}{)}\PYG{p}{;}
    \PYG{n}{close}\PYG{p}{(} \PYG{n}{ctx}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{fd} \PYG{p}{)}\PYG{p}{;}

    \PYG{n}{ctx}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{fd} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Sowohl beim initialisieren als auch beim freigeben wurde Nebenläufigkeit berücksichtig. Um diese problemlose Nebenläufigkeit in unserer eigenen Implementierung zu gewährleisten werden alle kritischen Vorgänge mit einem Mutex, bzw. Semaphore abgesichert. Der Code der das gewährleistet wird unter {\hyperref[\detokenize{seccom:heap-speicher}]{\emph{Heap Speicher}}} erläutert.


\subsubsection{Modbus}
\label{\detokenize{seccom:modbus}}
Um die TLS Implementierung optional zu halten wurde viel mit Präprozessoren gearbeitet. Wenn eine bestimmte Präprozessor definiert wird werden bestimmte Sektionen an Code ausgeführt, dadurch kann TLS einfach an\sphinxhyphen{} bzw. abgeschaltet werden. Zur Veranschaulichung wie das konkret in Code funktioniert dient folgendes Beispiel:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef USE\PYGZus{}TLS}
\PYG{c+c1}{// Code in diesem Bereich wird nur ausgeführt wenn USE\PYGZus{}TLS definiert ist.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{c+c1}{// Code in diesem Bereich wird nur ausgeführt wenn USE\PYGZus{}TLS *nicht* definiert ist.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}

Konkret wird diese Präprozessor über die Makefile gesetzt, lediglich nur wenn \sphinxcode{\sphinxupquote{make}} mit \sphinxcode{\sphinxupquote{config=tls}} aufgerufen wird.

Generell hat sich strukturell nicht viel geändert zur ursprünglichen Modbus Implementation, es wurden lediglich LWIP Funktionen mit denen von Mbed TLS ersetzt, und wenn \sphinxcode{\sphinxupquote{USE\_TLS}} definiert ist wird zusätzlich der TLS Handshake durchgeführt.


\subsection{Zertifikate}
\label{\detokenize{seccom:zertifikate}}
In \sphinxcode{\sphinxupquote{./tools/}} wurde ein Bash Skript mit dem Namen \sphinxcode{\sphinxupquote{create\_new\_certs\_with\_ca.sh}} erstellt.
Dieses Skript erstellt eine CA, sowie alle benötigten Zertifikate.
Zur Erstellung dieser Daten werden von Mbed TLS bereitgestellte Programme verwendet (\sphinxcode{\sphinxupquote{gen\_key}} und \sphinxcode{\sphinxupquote{cert\_write}}). Diese sind als Sourcecode auf GitHub zu finden:
\sphinxurl{https://github.com/ARMmbed/mbedtls/tree/development/programs}

Im Anschluss werden die erstellten Zertifikate mit der CA signiert.
Die CA (Certificate Authority) und ihre signierten Zertifikate werden in Ordnern des {\hyperref[\detokenize{seccom:secure-layer}]{\emph{Secure Layers}}} gespeichert.
Daraufhin werden die für die Remote\sphinxhyphen{}IOs benötigten Schlüssel und Zertifikate in eine Makefile exportiert, wodurch beim Bauen der Remote\sphinxhyphen{}IO Binaries diese alle benötigten Informationen erhalten.


\subsection{Fazit und Ausblick}
\label{\detokenize{seccom:fazit-und-ausblick}}



\subsubsection{Fazit}
\label{\detokenize{seccom:fazit}}
Durch die zusätzlichen Implementierungen kann nun optional zwischen der ursprünglich unverschlüsselten Modbus Verbindung und der durch das TLS\sphinxhyphen{}Protokoll verschlüsselten Verbindung ausgewählt werden. Zusätzlich zu der verschlüsselten Verbindung übernimmt das Protokoll auch die Überprüfung der Authentizität der Kommunikationspartner. So muss bei einem Verbindungsaufbau das Remote\sphinxhyphen{}IO mit einem Zertifikat belegen, dass dieser dem LICSTER\sphinxhyphen{}Netzwerk zugehörig ist.


\subsubsection{Ausblick}
\label{\detokenize{seccom:ausblick}}
Nach der durch die Verschlüsselung der Kommunikationswege zwischen dem PLC und der Remote\sphinxhyphen{}IOs errungenen Sicherheit kann an der Beschleunigung des TLS\sphinxhyphen{}Handshakes gearbeitet werden. Durch verwenden eines Secure Elements kann der momentan sehr langsame Verbindungsaufbau von etwa 10 Sekunden beschleunigt werden. Solch ein Microchip würde zusätzliche Sicherheit mit sich bringen, da die Privat Keys dieser unzugänglich sind. Nach der Verbesserung der Performance des Protokolls könnte die sichere Modbus Verbindung auch auf die weiteren Komponenten (HMI und SCADA) des Netzwerkes ausgeweitet werden. Um eine höhere Authentizität im LICSTER\sphinxhyphen{}Netzwerk zu erreichen könnte man die Client Authentifizierung derartig erweitern, dass zusätzlich zu den Remote\sphinxhyphen{}IOs auch das PLC mithilfe von Zertifikaten seine Zugehörigkeit bestätigen muss.


\section{Webapplikation Backend}
\label{\detokenize{webapp:webapplikation-backend}}\label{\detokenize{webapp::doc}}

\subsection{Einleitung}
\label{\detokenize{webapp:einleitung}}
Unsere Aufgabe war es die Web\sphinxhyphen{}Applikation des LICSTER zu verbessern.

Konkret haben wir das Frontent für mehrere Geräte zugänglich gemacht und das Backend um eine Benutzerverwaltung erweitert. Des weiteren haben wir ein PIN\sphinxhyphen{}Feld für das HMI programmiert, die Datenbank der Benutzerverwaltung von der Kommandozeile aufsetzbar gemacht und die Logs des IDS zeigen wir nicht nur auf dem Admin Dashboard an, sondern benachrichtigen Admins auch über Breaches per Email. Ein WSGI (Web Server Gateway Interface) wurde implementiert, um die Einbindung eines Web Servers für Endbenutzer zu vereinfachen.


\subsection{Anfangsstand}
\label{\detokenize{webapp:anfangsstand}}
Die Flask Applikation der ersten LICSTER Gruppe war ein abgeschlossenes System, welches nur zur Benutzung auf dem HMI konzipiert war. Sie zeigt den Stand aller Servomotoren an, kann Orders anzeigen und plazieren und Motoren einzeln ansteuern.

Sie in einem Unternehmensnetzwerk laufen zu lassen wäre ein Sicherheitsrisiko gewesen, da jeder die Motoren bedienen konnte. Des weiteren würde es Anzeigeprobleme geben, da die Web Applikation nur für einen Bildschirm \sphinxhyphen{} den des HMI \sphinxhyphen{} programmiert wurde.

Im Folgenden präsentieren wir unsere Veränderungen und Erweiterungen.


\bigskip\hrule\bigskip



\subsection{Veränderungen}
\label{\detokenize{webapp:veranderungen}}

\subsubsection{Modularer Aufbau}
\label{\detokenize{webapp:modularer-aufbau}}
Die bestehende Webapp war eine Standart Flask App. Da wir sowohl eine Datenbank als auch Wege zum Administrieren und Einloggen hinzufügen wollten, haben wir uns dazu entschlossen der Flask App einen Modularen Aufbau zu geben. Dieser Aufbau wird es auch zukünftigen Gruppen erleichtern sich in die App einzuarbeiten und neue Funktionalitäten hinzuzufügen.

Flask \sphinxhyphen{} im Gegensatz zu anderen populären Frameworks wie z.B. Django hat keinen vorgegebenen Applikationsaufbau. Daher kann man wie folgt eine funktionsfähige Flask Web Applikation schreiben, die (sobald die app mit \sphinxcode{\sphinxupquote{flask run}} gestartet wurde) unter localhost:5000/ „Hello World!“ anzeigt.

app.py

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{flask} \PYG{k+kn}{import} \PYG{n}{Flask}
\PYG{n}{app} \PYG{o}{=} \PYG{n}{Flask}\PYG{p}{(}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{)}

\PYG{n+nd}{@app}\PYG{o}{.}\PYG{n}{route}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{hello}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello World!}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
\PYG{n}{app}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Mit jeder hinzugefügten Route wird dieses File allerdings unübersichtlicher, weswegen es sich anbietet die App in verschiede Files aufzugliedern. Wir haben uns dafür entschieden die Flask Applikation wie folgt aufzugliedern:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{app}\PYG{o}{/}                \PYG{c+c1}{\PYGZsh{} Alles was direkt mit dem Ablauf der App zu tun hat}
\PYG{n}{app}\PYG{o}{/}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{o}{.}\PYG{n}{py}     \PYG{c+c1}{\PYGZsh{} Die Application Factory}
\PYG{n}{app}\PYG{o}{/}\PYG{n}{admins}\PYG{o}{.}\PYG{n}{py}       \PYG{c+c1}{\PYGZsh{} Alle Administrationsteile der Applikation}
\PYG{n}{app}\PYG{o}{/}\PYG{n}{auths}\PYG{o}{.}\PYG{n}{py}        \PYG{c+c1}{\PYGZsh{} Alle Authentifikationsteile der Applikation}
\PYG{n}{app}\PYG{o}{/}\PYG{n}{db}\PYG{o}{.}\PYG{n}{py}           \PYG{c+c1}{\PYGZsh{} Das Handling der Datenbankverbindung}
\PYG{n}{app}\PYG{o}{/}\PYG{n}{forms}\PYG{o}{.}\PYG{n}{py}        \PYG{c+c1}{\PYGZsh{} Das Handling aller Forms}
\PYG{n}{app}\PYG{o}{/}\PYG{n}{views}\PYG{o}{.}\PYG{n}{py}        \PYG{c+c1}{\PYGZsh{} Alle Routen zur Bedienung des LICSTER}
\PYG{n}{app}\PYG{o}{/}\PYG{n}{templates}\PYG{o}{/}      \PYG{c+c1}{\PYGZsh{} Alle HTML Templates der App}
\PYG{n}{app}\PYG{o}{/}\PYG{n}{static}\PYG{o}{/}         \PYG{c+c1}{\PYGZsh{} Die CSS, JavaScript, JQuery und Bootstrap Dateien der App}
\PYG{n}{wsgi}\PYG{o}{.}\PYG{n}{py}             \PYG{c+c1}{\PYGZsh{} Wird benötigt, um die App mit einem WSGI zu starten}
\end{sphinxVerbatim}

admins.py, auths.py und views.py sind als Blueprints aufgebaut. Diese Blueprints werden in der main bzw create\_app Funktion registriert. Danach funktionieren die Routen der einzelnen Files genauso wie die Routen eines app.py Files.


\subsubsection{Application Factory}
\label{\detokenize{webapp:application-factory}}
Eine Application Factory ist eine Funktion, die das globale App Object generiert und zurückgibt. Dies hat verschiedene Vorteile, z.B. ermöglicht es eine einfache Implementierung eines WSGI, das Testen mit verschiedenen globalen Konfigurationen und das einfache Hinzufügen von eigenen CLI Befehlen.

Zur Implementierung der Application Faktory haben wir den Startpunkt der App aus app.py in app/\_\_init\_\_ verlegt. Der Startpunkt ist nun die Funktion create\_app(), welche als erstes eine Flask App kreiert, sie dann konfiguriert und als letztes alle Blueprints registriert, bevor sie die App zurückgibt.


\subsubsection{Design}
\label{\detokenize{webapp:design}}
Für das Design haben wir uns zusammengesetzt und beschlossen dass ein schlichteres Design ohne viele visuelle Features besser ist. Es handelt sich nämlich um ein IT\sphinxhyphen{}Sicherheits\sphinxhyphen{}Projekt bei dem natürlich die Sicherheit des Systems an erster Stelle steht und es seriös wirken soll.

\sphinxhref{https://i.imgur.com/Q6q6D2v.png}{}

Für das PIN\sphinxhyphen{}Feld wurde eine JavaScript Klasse erstellt, welche für die Anzeige der Tasten und das Handling von Eingaben zuständig ist. Diese Anzeige ist nicht für mehrere Geräte angelegt sondern direkt auf das HMI angepasst.

\sphinxhref{https://i.imgur.com/XV7jQDH.gif}{}

Die normale Anmeldeseite wurde so realisiert, dass sie auf allen Geräten gut verwendet werden kann.


\bigskip\hrule\bigskip



\subsection{Erweiterungen}
\label{\detokenize{webapp:erweiterungen}}
Als zwei Große Erweiterungen wurden das Benutzerverwaltungssytem und der Auswertung und Anzeige der IDS Logs zur Web Applikation hinzugefügt.

Im Benutzerverwaltungssytem gibt es drei Rollen, Admins, Users und nicht angemeldete Personen. Nicht angemeldete Personen haben die Möglichkeit die Startseite der Webapplikation zu besuchen. Andere Webseiten können sie allerdings nicht besuchen, da dies ein Sicherheitsrisiko wäre.

Angemeldete Benutzer können LICSTER wie zuvor auf dem Bildschirm des HMI nun über jedes Gerät, welches ihnen zur Verfügung steht bedienen.

Die dritte Rolle des Benutzverwaltungssystems erlaubt den Zugriff auf das Administratoren Dashboard, wo Benutzer hinzugefügt und gelöscht werden. Hier werden außerdem alle Nutzer tabellarisch angezeigt. Des Weiteren werden tabellarisch IDS Logs auf dem Dashboard angezeigt, falls der Benutzer dies aktiviert hat und bei Hinzufügen einer Email\sphinxhyphen{}Adressse zu einem Admin Account wird der Benutzer über Breaches direkt per Email benachrichtigt.

Das Styling der Admin Dashboard\sphinxhyphen{}Ansicht wurde mithilfe von HTML und CSS (Cascade Style Sheets) verwirklicht. Hierbei haben wir beschlossen das alle Funktionen auf einer einzigen Seite sind, damit es übersichtlich bleibt und die Bedienung schneller ist.

\sphinxhref{https://i.imgur.com/wMhk1h6.png}{}

Zusätzlich gibt noch eine Reset\sphinxhyphen{}Funktion mit der man alle snort Einträge aus der Datenbank löschen kann.


\subsubsection{Datenbank}
\label{\detokenize{webapp:datenbank}}
Zur Speicherung der Benutzer, IP Adressen und IDS Logs haben wir eine SQLite Datenbank verwendet, da diese nicht viel Platz braucht und kein Datenbankverwaltungssystem braucht.

Um die Datenbank schnell aufsetzen zu können und das Passwort fürs HMI schnell verändern zu können wurden die Shortcuts \sphinxcode{\sphinxupquote{flask init\sphinxhyphen{}db}} und \sphinxcode{\sphinxupquote{flask change\sphinxhyphen{}hmi\sphinxhyphen{}password}} implementiert. Wir haben uns gegen Standart Benutzeraccounts und Passwörter entschieden, da diese ein Sicherheitsrisiko darstellen könnten und man die Datenbank normalerweise nur ein einziges Mal aufsetzen muss.

Das Passwort wird beim Erstellen eines Benutzers mit der generate\_password\_hash Methode von Werkzeug gehasht, der gehashte Wert wird dann gespeichert. Beim Login wird die check\_password\_hash Methode von Werkzeug verwendet. Wir haben uns gegen die Implementierung eines Salts entschieden, da es uns unsinnig erschien die Datenbank gegen Rainbow Table Attacks zu schützen.


\subsubsection{Formen}
\label{\detokenize{webapp:formen}}
Um CSRF\sphinxhyphen{}Attacken, insbesondere Session\sphinxhyphen{}Riding Attacken zu verhinden, bei denen Daten mithilfe einer gültigen Sitzung des Opfers manipuliert werden, haben wir für alle Formen FlaskForms verwendet. Dies ist eine im Paket WTForms enthaltene Klasse, welche resistent gegen CSRF\sphinxhyphen{}Attacken ist. Jede Subklasse von FlaskForms integriert Tokens in die HTML Formen und überprüft die in der zurückgeschickten Form enthaltenen Tokens mithilfe der validate\_on\_submit Methode automatisch.


\subsubsection{Authentication}
\label{\detokenize{webapp:authentication}}
Für alle Routen, die zum An\sphinxhyphen{} und Abmelden von Benutzern gehören haben wir das auths Blueprint hinzugefügt.

Die Login\sphinxhyphen{}Route überprüft über die validate\_on\_submit Methode aller FlaskForms, ob eine valide Form gepostet wurde und falls dies nicht der Fall ist wird dem Benutzer eine Form geschickt. Basierend auf die IP Adresse wird dem Benutzer entweder HTML Seite des HMI oder die normale Login Seite geschickt.

Wenn die validate\_on\_submit Methode True zurückgibt, wird überprüft wer der Benutzer ist. Danach erfolgt ein Passwortabgleich. Falls dieser auch erfolgreich ist wird der Session eine Variable mit der Benutzerrolle
hinzugefügt. Falls sich der Benutzer zum ersten Mal anmeldet, wird er nun weitergeleitet zum Passwort setzen. Andernfalls werden normale Benutzer (also auch HMI Benutzer) zur Startseite weitergeleitet und Administratoren zum Dashboard.

Die Route zum Paswswort überprüft genauso wie die Login Route über die validate\_on\_submit Methode, ob eine valide Form gepostet wurde und falls dies nicht der Fall ist wird dem Benutzer eine Form geschickt. Wenn der Benutzer ein Passwort eingibt, ersetzt der Hash dieses Passworts den bisherigen Hash in der Datenbank und das Feld für first\_login wird auf False bzw. 0 gesetzt.


\subsubsection{Administration}
\label{\detokenize{webapp:administration}}
Für alle Routen, die zur Benutzeradministration gehören haben wir das admins Blueprint hinzugefügt.

Das Admin Dashboard gibt den Administratoren einen Überblick über alle vorhandenen User und alle vorhandenen Logs. Des weiteren gibt es einen Button zum Zurücksetzen der Snort Logs.

Auf dem Admin Dashboard gibt es drei Formen. Die erste Form ist zum Erstellen von Usern. Der Admin muss einen Benutzernamen, ein Passwort und eine Benutzerrolle vergeben. Falls die Benutzerrolle Admin ist, so kann er diesem Benutzer auch eine Email Adresse zuweisen. Zum Löschen eines Benutzers muss der Admin einfach den Benutzernamen in die zweite Form eingeben und auf Löschen klicken. Die letzte Form ist zum Löschen von den Snort Logs.


\subsubsection{IDS Implementation}
\label{\detokenize{webapp:ids-implementation}}
Zusammen mit dem IDS\sphinxhyphen{}Team haben wir an einer Lösung gearbeitet um den Administratoren Zugang zu den Logs zu geben. Dazu haben wir einen Log\sphinxhyphen{}Reader geschrieben, welcher die vom IDS übermittelten Logs auf Veränderungen überprüft und neue Daten in die Datenbank einträgt. Auf dem Admin\sphinxhyphen{}Dashboard werden diese in einer Tabelle angezeigt. Des Weiteren werden Admins \sphinxhyphen{} sofern sie sich mit einer Email\sphinxhyphen{}Adresse registriert haben \sphinxhyphen{} direkt über Sicherheitsverstöße informiert. Die IDS Implementierung ist eine optionale Funktion.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{o}{*}\PYG{o}{*}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{1001005}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{n}{Modbus} \PYG{n}{threshold} \PYG{n}{violation} \PYG{l+m+mi}{52} \PYG{p}{[}\PYG{o}{*}\PYG{o}{*}\PYG{p}{]}
\PYG{p}{[}\PYG{n}{Classification}\PYG{p}{:} \PYG{n}{Attempted} \PYG{n}{Denial} \PYG{n}{of} \PYG{n}{Service}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Priority}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{l+m+mi}{05}\PYG{o}{/}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{13}\PYG{p}{:}\PYG{l+m+mi}{42}\PYG{p}{:}\PYG{l+m+mf}{01.732170} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{0.30}\PYG{p}{:}\PYG{l+m+mi}{46084} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{0.52}\PYG{p}{:}\PYG{l+m+mi}{502}
\PYG{n}{TCP} \PYG{n}{TTL}\PYG{p}{:}\PYG{l+m+mi}{64} \PYG{n}{TOS}\PYG{p}{:}\PYG{l+m+mh}{0x10} \PYG{n}{ID}\PYG{p}{:}\PYG{l+m+mi}{48012} \PYG{n}{IpLen}\PYG{p}{:}\PYG{l+m+mi}{20} \PYG{n}{DgmLen}\PYG{p}{:}\PYG{l+m+mi}{40} \PYG{n}{DF}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{n}{A}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Seq}\PYG{p}{:} \PYG{l+m+mh}{0x14371674}  \PYG{n}{Ack}\PYG{p}{:} \PYG{l+m+mh}{0x3ED77}  \PYG{n}{Win}\PYG{p}{:} \PYG{l+m+mh}{0x7210}  \PYG{n}{TcpLen}\PYG{p}{:} \PYG{l+m+mi}{20}
\end{sphinxVerbatim}

Ein Snort Log Eintrag hat den oben abgebildeten Aufbau. Um auf den Dashboard nur relevante Daten anzuzeigen, filtern wir den Typ, die Klassifikation, die Priorität und den Zeitpunkt aus den Log Einträgen.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{db} \PYG{o}{=} \PYG{n}{get\PYGZus{}db}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{last\PYGZus{}row} \PYG{o}{=} \PYG{n}{db}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SELECT * FROM snort WHERE   id = (SELECT MAX(id) FROM snort)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fetchone}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{last\PYGZus{}row} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{)} \PYG{o+ow}{or} \PYG{p}{(}\PYG{n}{last\PYGZus{}row}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{!=} \PYG{n}{Type} \PYG{o+ow}{or} \PYG{n}{last\PYGZus{}row}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{!=} \PYG{n}{Classification} \PYG{o+ow}{or} \PYG{n}{last\PYGZus{}row}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{!=} \PYG{n}{Priority}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{db}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{INSERT INTO snort (snort\PYGZus{}type, snort\PYGZus{}classification, snort\PYGZus{}priority, snort\PYGZus{}datetime) VALUES (?,?,?,?)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{(}\PYG{n}{Type}\PYG{p}{,} \PYG{n}{Classification}\PYG{p}{,} \PYG{n}{Priority}\PYG{p}{,} \PYG{n}{Datetime}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{db}\PYG{o}{.}\PYG{n}{commit}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Um Platz in der Datenbank zu sparen und die Email Accounts nicht mit gleichen Warnungen zu überfluten, haben wir uns dazu entschlossen nur neue Logs in der Datenbank zu speichern. Dazu überprüfen wir ob entweder die Datenbank Tabelle leer ist oder der Typ, die Klassifikation oder die Priorität des Logs sich verändert hat. Nur wenn einer der beiden Fälle eintritt, wird ein neuer Eintrag abgespeichert und eine Email versendet.


\subsubsection{Warnungen per Mail}
\label{\detokenize{webapp:warnungen-per-mail}}
Wenn das Intrusion Detection System Verstöße entdeckt, wird eine Email an alle Administratoren mit einer eingetragenen Email verschickt. Dies wurde mithilfe des smtplib Pakets realisiert. Als Absender haben wir eine dafür dedizierte Email\sphinxhyphen{}Adresse verwendet. Diese sensiblen Daten sollten logischerweise nach dem Entwicklungsstadium durch Umgebungsvariablen ausgetauscht werden, da dies ansonsten ein Sicherheitsrisiko darstellen würde.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{smtp}\PYG{o}{.}\PYG{n}{login}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{licster.breach@gmail.com}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Lic\PYGZsh{}v77zX}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{WSGI}
\label{\detokenize{webapp:wsgi}}
Um die leichte Einbindung in einen Server wie nginx zu gewährtleisten, haben wir uns dazu entschlossen ein WSGI einzubinden. Wir haben Gunicorn ausgewählt und ein wsgi.py File erstellt, welches mit der create\_app Funktion eine App kreiert und dann startet.


\bigskip\hrule\bigskip



\subsection{Fazit und Ausblick}
\label{\detokenize{webapp:fazit-und-ausblick}}

\subsubsection{Fazit}
\label{\detokenize{webapp:fazit}}
LICSTER zu verbessern war ein interessantes und forderndes Projekt. Wir mussten uns mit dem Framework Flask auseinandersetzen und in ein bestehendes Projekt einarbeiten. Es hat jedoch auch Spaß gemacht ein bestehendes Projekt durch eigene Funktionalitäten erweitern zu können. Wir haben die Web Applikation geräteübergreifend zugänglich gemacht und ein Benutzerverwaltungssystem hinzugefügt.


\subsubsection{Ausblick}
\label{\detokenize{webapp:ausblick}}
Bisher läuft die Server\sphinxhyphen{}Client Kommunikation über HTTP. Dies stellt ein Sicherheitsrisiko dar, da Benutzernamen und Passwörter unverschlüsselt über das Netz übertragen werden. Es ist möglich, HTTPS mithilfe von Self\sphinxhyphen{}Signed Certificates zu implementieren. Eine Anleitung hierzu kann unter \sphinxurl{https://gist.github.com/fntlnz/cf14feb5a46b2eda428e000157447309} gefunden werden. Google Chrome hat spezifische Anforderungen an die Zertifikate, welche Probleme verursachen können. Ein Thread zu diesem Problem kann unter \sphinxurl{https://github.com/webpack/webpack-dev-server/issues/854} gefunden werden.

Aktuell werden Admins via Email unverzüglich über Sicherheitsverstöße benachrichtigt, das Selbe gilt allerdings nicht für das Admin Dashboard. Eine hilfreiche Erweiterung wäre die Implementierung einer Threadlevel Anzeige auf dem Admin Dashboard. Diese sollte automatisch das Sicherheitslevel updaten. Realisiert werden könnte dies z.B. durch eine Socket\sphinxhyphen{}Verbindung zwischen der Web Applikation und den Clients. Eine Anleitung zum Implementieren einer Socket\sphinxhyphen{}Verbindung kann unter dem folgenden Link gefunden werden: \sphinxurl{https://www.includehelp.com/python/implementation-of-websocket-using-flask-socket-io-in-python.aspx}


\section{Probleme}
\label{\detokenize{probleme:probleme}}\label{\detokenize{probleme::doc}}
Das Projekt LICSTER wurde 2020 etwas von der COVID\sphinxhyphen{}19 Pandemie beinträchtigt, da der physische Zugang zu dem LICSTER\sphinxhyphen{}Gerät anfangs nicht möglich war. Dies war der Grund wieso beschlossen wurde den Zugang über andere Wege zu realisieren.


\subsection{Zugriff auf das LICSTER}
\label{\detokenize{probleme:zugriff-auf-das-licster}}
\sphinxhref{https://i.imgur.com/aa2UK60.png}{}

Der physische Zugriff auf das Testsystem welches beim Projektaufseher vor Ort installiert war, wurde durch Teamviewer und SSH ersetzt. Durch diesen Teamviewer Zugriff waren wir dann trotzdem in der Lage das Gerät ein\sphinxhyphen{} und auszuschalten und die Kamera zu rebooten.


\subsection{Projekttag}
\label{\detokenize{probleme:projekttag}}
Der Projekttag war ebenfalls von der Pandemie beeinträchtigt jedoch war es uns möglich eine gemeinsame Präsentation über Microsoft Powerpoint online zu erstellen und diese auch an unseren Vortrag anzupassen.


\section{Index}
\label{\detokenize{index:index}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Stichwortverzeichnis}
\printindex
\end{document}